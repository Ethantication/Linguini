<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Linguini - Cracking The Language Barrier</title>
    
    <!-- Favicon: Added for tab view logo (Request 4) -->
    <link rel="icon" href="https://raw.githubusercontent.com/Ethantication/Linguini/main/lingimg.jpg" type="image/jpeg">

    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    
    <!-- PapaParse for CSV parsing (used for potential future CSV uploads, not strictly for download but good to have) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>

    <style>
        /* Base styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #F8F9FA; /* Lightest gray for overall background */
            color: #343A40; /* Dark gray for main text */
            line-height: 1.6;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1.5rem; /* Increased padding */
        }

        /* Card styling - more prominent shadow, softer corners */
        .card {
            background-color: #ffffff;
            border-radius: 0.75rem; /* rounded-xl */
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1); /* Softer, more spread out shadow */
            padding: 2rem; /* Increased padding */
            margin-bottom: 2rem; /* Increased margin */
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .card:hover {
            transform: translateY(-5px); /* Slight lift on hover */
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.15);
        }

        /* Input and textarea styling - refined borders, clear focus */
        input[type="text"], textarea, select, input[type="number"] { /* Added input[type="number"] */
            border: 1px solid #CED4DA; /* Lighter gray border */
            border-radius: 0.5rem; /* Slightly more rounded */
            padding: 0.75rem 1rem;
            width: 100%;
            font-size: 1rem;
            color: #343A40;
            background-color: #ffffff;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        input[type="text"]:focus, textarea:focus, select:focus, input[type="number"]:focus { /* Added input[type="number"] */
            outline: none;
            border-color: #4CAF50; /* Accent green for focus */
            box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.25); /* Green shadow for focus */
        }
        /* Specific style for number input arrows */
        input[type="number"]::-webkit-outer-spin-button,
        input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type="number"] {
            -moz-appearance: textfield;
        }

        /* Button styling - primary accent color, subtle hover effects */
        button {
            background-color: #4CAF50; /* Primary accent green */
            color: white;
            padding: 0.85rem 1.75rem; /* More generous padding */
            border-radius: 0.625rem; /* rounded-lg */
            font-weight: 600;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out, box-shadow 0.2s ease-in-out;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15); /* Soft shadow */
            display: inline-flex; /* For icons to be centered */
            align-items: center;
            justify-content: center;
            gap: 0.5rem; /* Space between icon and text */
        }
        button:hover {
            background-color: #43A047; /* Darker green on hover */
            transform: translateY(-2px); /* Slightly more pronounced lift */
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* Secondary button style */
        .btn-secondary {
            background-color: #98B4AA; /* Muted blue-gray */
            color: #343A40; /* Dark text for contrast */
            box-shadow: none; /* No shadow by default for secondary */
        }
        .btn-secondary:hover {
            background-color: #7A908D; /* Darker muted blue-gray */
            color: white; /* Text turns white on hover for better contrast */
            transform: translateY(-1px);
        }
        .btn-secondary:active {
            transform: translateY(0);
        }

        /* Specific button styles (kept for functionality, integrated with new palette) */
        .btn-validate { background-color: #28A745; } /* Bootstrap success green */
        .btn-validate:hover { background-color: #218838; }
        .btn-edit { background-color: #FFC107; color: #343A40; } /* Bootstrap warning yellow, dark text */
        .btn-edit:hover { background-color: #E0A800; }
        .btn-delete { background-color: #DC3545; } /* Bootstrap danger red */
        .btn-delete:hover { background-color: #C82333; }

        /* Status colors */
        .status-pending { color: #FFC107; font-weight: 500; }
        .status-validated { color: #28A745; font-weight: 500; }
        .status-not-provided { color: #6C757D; font-style: italic; } /* Muted gray */
        .status-overall-fully-validated { color: #198754; font-weight: 600; } /* Darker green */
        .status-overall-partially-validated { color: #FFC107; font-weight: 600; }
        .status-overall-pending { color: #DC3545; font-weight: 600; }

        /* Message box styling (used for custom prompts as well) */
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 2.5rem; /* More padding */
            border-radius: 0.75rem;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.25); /* Deeper shadow */
            z-index: 1000;
            text-align: center;
            min-width: 320px;
            max-width: 90%;
            border: 1px solid #E9ECEF; /* Subtle border */
        }
        .message-box-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6); /* Darker overlay */
            z-index: 999;
        }

        /* Table styling - refined borders and padding */
        .term-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1.5rem; /* More space */
            border-radius: 0.5rem; /* Rounded table corners */
            overflow: hidden; /* Ensures rounded corners are visible */
        }
        .term-table th, .term-table td {
            border: 1px solid #E9ECEF; /* Lighter border for cells */
            padding: 1rem; /* More padding */
            text-align: left;
            vertical-align: middle;
        }
        .term-table th {
            background-color: #F0F2F5; /* Very light gray for header */
            font-weight: 600;
            color: #343A40;
            text-transform: uppercase;
            font-size: 0.9rem;
            letter-spacing: 0.05em;
        }
        .term-table tr:nth-child(even) {
            background-color: #F8F9FA; /* Subtle zebra striping */
        }

        /* Mobile adjustment for tables (Request 2) */
        @media (max-width: 768px) {
            .term-table, .term-table thead, .term-table tbody, .term-table th, .term-table td, .term-table tr {
                display: block;
            }
            .term-table thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }
            .term-table tr {
                border: 1px solid #E9ECEF;
                margin-bottom: 0.625rem; /* Add some space between rows */
                border-radius: 0.5rem;
                overflow: hidden;
            }
            .term-table td {
                border: none; /* Remove individual cell borders */
                border-bottom: 1px solid #E9ECEF; /* Keep bottom border for separation within a "row" */
                position: relative;
                padding-left: 50%; /* Make space for the pseudo-element label */
                text-align: right;
                word-wrap: break-word; /* Allow long words to break */
                white-space: normal; /* Allow text to wrap */
            }
            .term-table td:before {
                position: absolute;
                top: 0;
                left: 6px;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                text-align: left;
                font-weight: 600;
                color: #6C757D;
                content: attr(data-label); /* Use data-label for content */
            }
            /* Specific labels for mobile table cells */
            .term-table td:nth-of-type(1):before { content: "Language"; }
            .term-table td:nth-of-type(2):before { content: "Translation"; }
            .term-table td:nth-of-type(3):before { content: "Status"; }
            .term-table td:nth-of-type(4):before { content: "Actions"; }
        }


        /* Custom header background color */
        .bg-header-custom {
            background-color: #faeddb;
            color: #343A40; /* Text color for header content */
            padding: 1rem 0; /* Reduced padding for a tighter header */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05); /* Lighter header shadow */
        }
        .bg-header-custom .container {
            padding-top: 0.5rem;
            padding-bottom: 0.5rem;
        }
        .bg-header-custom button {
            background-color: #ffffff; /* White background for header buttons */
            color: #4CAF50; /* Green text for header buttons */
            padding: 0.6rem 1.2rem; /* Adjusted padding for header buttons */
            font-weight: 500;
            font-size: 0.95rem;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.08);
        }
        .bg-header-custom button:hover {
            background-color: #F0F2F5; /* Light gray on hover */
            color: #388E3C; /* Darker green on hover */
            transform: translateY(-1px);
        }

        /* Game specific styles (Linguini Challenge and Learn Hebrew) */
        .game-option-button, .learn-hebrew-option-button {
            /* Using @apply for Tailwind classes within custom CSS is not directly supported in plain HTML,
               but the styles below mimic what Tailwind would do if compiled.
               For actual Tailwind use, these should be applied directly in HTML class attributes. */
            background-color: #4CAF50; /* bg-4CAF50 */
            color: white; /* text-white */
            padding-top: 1rem; /* py-4 */
            padding-bottom: 1rem; /* py-4 */
            padding-left: 1.5rem; /* px-6 */
            padding-right: 1.5rem; /* px-6 */
            border-radius: 0.5rem; /* rounded-lg */
            font-size: 1.5rem; /* text-2xl */
            font-weight: 700; /* font-bold */
            width: 100%; /* w-full */
            transition: all 0.2s ease-in-out; /* transition-all duration-200 ease-in-out */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* shadow-md */
        }
        .game-option-button:hover, .learn-hebrew-option-button:hover {
            background-color: #43A047; /* bg-43A047 */
            transform: scale(1.02); /* transform scale-102 */
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1); /* shadow-lg */
        }
        .game-option-button.correct, .learn-hebrew-option-button.correct {
            background-color: #28A745; /* bg-28A745 */
        }
        .game-option-button.incorrect, .learn-hebrew-option-button.incorrect {
            background-color: #DC3545; /* bg-DC3545 */
        }

        /* Learn Hebrew specific styles */
        #hebrewTermDisplay {
            font-size: 6rem; /* Even larger for impact */
            line-height: 1;
            margin-bottom: 0.5rem;
        }
        #pronunciationDisplay {
            font-size: 1.8rem;
            color: #6C757D;
        }
        #learnHebrewFeedback {
            font-size: 1.8rem;
        }

        /* Flexbox for footer content */
        .footer-content {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem; /* Space between text and mascot */
        }

        /* Remi the mouse specific style */
        .remi-mascot {
            height: 4rem; /* Adjust size as needed */
            width: auto;
            border-radius: 9999px; /* Fully rounded */
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        /* Debug Info Styling */
        #debugInfo {
            font-size: 0.75rem;
            color: #A0A0A0;
            margin-top: 1rem;
            text-align: center;
        }
        #debugInfo span {
            font-weight: bold;
            color: #E0E0E0;
        }

        /* Added for mobile responsiveness: Ensure header elements stack on small screens (Request 2) */
        @media (max-width: 767px) {
            .bg-header-custom .container {
                flex-direction: column;
                align-items: center;
            }
            .bg-header-custom nav {
                flex-direction: column;
                width: 100%;
            }
            .bg-header-custom nav button {
                width: 100%;
                margin-bottom: 0.5rem;
            }
            .bg-header-custom .flex.justify-center.md\:justify-start {
                width: 100%;
                justify-content: center;
            }
            .footer-content {
                flex-direction: column;
                gap: 0.5rem;
            }
            .footer-content img {
                margin-top: 0.5rem; /* Space between text and mascots on mobile */
            }
        }

        /* Styles for the new language proficiency modal */
        #languageProficiencyModal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border: 1px solid #ccc;
            z-index: 1000; /* Ensure it's on top of other content */
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            border-radius: 10px;
            width: 90%;
            max-width: 450px;
            box-sizing: border-box;
            display: none; /* Initially hidden */
        }

        #languageProficiencyModal h2 {
            margin-top: 0;
            color: #333;
            text-align: center;
            margin-bottom: 20px;
        }

        #languageProficiencyModal p {
            margin-bottom: 10px;
            color: #555;
        }

        #languageProficiencyModal div.button-group { /* Specific class for modal buttons div */
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px; /* Space above buttons */
        }

        /* Ensure modal buttons use general button styles or apply custom ones */
        #languageProficiencyModal button {
             padding: 10px 20px;
             border-radius: 5px;
             font-size: 16px;
             box-shadow: none; /* Remove default button shadow for cleaner modal buttons */
        }
        #languageProficiencyModal #submitValidatorApplication {
            background-color: #28a745; /* Success green */
            color: white;
        }
        #languageProficiencyModal #submitValidatorApplication:hover {
            background-color: #218838;
        }
        #languageProficiencyModal #cancelValidatorApplication {
            background-color: #f44336; /* Danger red */
            color: white;
        }
        #languageProficiencyModal #cancelValidatorApplication:hover {
            background-color: #c82333;
        }

    </style>
</head>
<body class="min-h-screen flex flex-col">
    <header class="bg-header-custom p-4 shadow-lg">
        <div class="container flex flex-col md:flex-row md:justify-between md:items-center">
            <div class="flex justify-center md:justify-start mb-4 md:mb-0">
                <img src="https://raw.githubusercontent.com/Ethantication/Linguini/main/lingimg.jpg" alt="Linguini Logo" class="h-24 w-24 md:h-20 md:w-20 rounded-full shadow-md">
            </div>
            <nav class="flex flex-wrap justify-center gap-3 md:gap-4 mt-2 md:mt-0">
                <button id="homeButton">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m0 0l7 7m-2 2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"/>
                    </svg>
                    Home
                </button>
                <button id="validatorAuthButton">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/>
                        <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
                    </svg>
                    Validator Login
                </button>
		    
               <button id="becomeValidator">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/>
                        <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
                    </svg>
                    Become a Validator
                </button>
                <button id="challengeGameButton">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M11 3.055A9.001 9.001 0 1020.945 13H11V3.055z"/>
                        <path stroke-linecap="round" stroke-linejoin="round" d="M20.488 9H15V3.512A9.025 9.025 0 0120.488 9z"/>
                    </svg>
                    Linguini Challenge
                </button>
                <button id="searchButton">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
                    </svg>
                    Search
                </button>
                <button id="learnHebrewButton">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M12 6.253v13.4M3.344 11.516l-.008.008A9.752 9.752 0 0012 21.75a9.753 9.753 0 008.657-4.929l-.008-.008-1.339-2.679m0 0l-.952-1.904A2.25 2.25 0 0015.688 9.442l4.474-4.474A9.753 9.753 0 0012 2.25c-2.895 0-5.689 1.173-7.776 3.26l-.008.008z"/>
                    </svg>
                    Learn Hebrew
                </button>
            </nav>
        </div>
    </header>

    <main class="flex-grow container py-8">
        <div id="messageBoxContainer"></div>

        <div id="homeView" class="view">
            <div class="card">
                <h2 class="text-3xl font-bold mb-4 text-center">Welcome to Linguini! <img src="https://raw.githubusercontent.com/Ethantication/Linguini/main/WhatsApp%20Image%202025-05-19%20at%2019.42.36_a4a2cf4b.jpg" alt="Remi the Mouse" class="inline-block remi-mascot ml-2"></h2>
                <p class="text-lg text-center mb-6 text-gray-700">Your go-to resource for Technion course terms, translated into multiple languages.</p>
                <div class="flex flex-col sm:flex-row justify-center gap-4">
                    <button id="showAddCourseFormBtn" class="w-full sm:w-auto">Add New Course</button>
                </div>
            </div>

            <div class="card">
                <h2 class="text-2xl font-semibold mb-4">Available Courses</h2>
                <div id="courseList" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    </div>
            </div>
        </div>

        <div id="searchView" class="view hidden">
            <div class="card">
                <h2 class="text-2xl font-semibold mb-4">Global Term Search <img src="https://raw.githubusercontent.com/Ethantication/Linguini/main/WhatsApp%20Image%202025-05-19%20at%2019.42.36_a4a2cf4b.jpg" alt="Remi the Mouse" class="inline-block remi-mascot ml-2"></h2>
                <div class="relative w-full mb-6">
                    <input type="text" id="globalSearchInput" placeholder="Search all terms..." class="pr-10">
                    <svg class="absolute right-3 top-1/2 -translate-y-1/2 h-5 w-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg>
                </div>
                <div id="searchResultsList" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    </div>
                <p id="noSearchResultsMessage" class="text-gray-500 text-center mt-4 hidden">No terms found matching your search.</p>
                <button id="clearSearchBtn" class="btn-secondary mt-6">Clear Search</button>
            </div>
        </div>

        <div id="addCourseView" class="view hidden">
            <div class="card">
                <h2 class="text-2xl font-semibold mb-6">Add New Course</h2>
                <form id="addCourseForm" class="space-y-4">
                    <div>
                        <label for="courseName" class="block text-sm font-medium text-gray-700 mb-1">Course Name</label>
                        <input type="text" id="courseName" placeholder="e.g., Calculus 1" required>
                    </div>
                    <div class="flex gap-4">
                        <button type="submit">Add Course</button>
                        <button type="button" id="cancelAddCourseBtn" class="btn-secondary">Cancel</button>
                    </div>
                </form>
            </div>
        </div>

        <div id="courseDetailsView" class="view hidden">
            <div class="card">
                <h2 id="courseDetailsTitle" class="text-2xl font-semibold mb-4"></h2>
                <p class="text-gray-700 mb-6">Terms for this course:</p>
                <div class="flex flex-col sm:flex-row gap-4 mb-6">
                    <button id="showAddTermFormBtn" class="w-full sm:w-auto">Add New Term to Course</button>
                    <!-- Search option within each course (Request 1) -->
                    <div class="relative w-full sm:w-1/2">
                        <input type="text" id="courseSearchInput" placeholder="Search terms in this course..." class="pr-10">
                        <svg class="absolute right-3 top-1/2 -translate-y-1/2 h-5 w-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg>
                    </div>
                    <!-- Download Excel file option (Request 3) -->
                    <button id="downloadTermsCsvBtn" class="w-full sm:w-auto btn-secondary">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M12 10.5v6m0 0l-3-3m3 3l3-3m2.75 0H19.5a2.25 2.25 0 012.25 2.25v2.75A2.25 2.25 0 0119.5 19.5H4.5a2.25 2.25 0 01-2.25-2.25v-2.75A2.25 2.25 0 014.5 14H6.25"/>
                        </svg>
                        Download All Terms (CSV)
                    </button>
                </div>
                <div id="termList" class="grid grid-cols-1 gap-4">
                    </div>
                <p id="noTermsMessage" class="text-gray-500 text-center mt-4 hidden">No terms found for this course. Be the first to add one!</p>
            </div>
        </div>

        <div id="addTermView" class="view hidden">
            <div class="card">
                <h2 id="addTermFormTitle" class="text-2xl font-semibold mb-6">Add New Term</h2>
                <form id="addTermForm" class="space-y-4">
                    <div>
                        <label for="termHebrew" class="block text-sm font-medium text-gray-700 mb-1">Term (Hebrew) <span class="text-red-500">*</span></label>
                        <input type="text" id="termHebrew" dir="rtl" placeholder="נגזרת" required>
                    </div>
                    <div>
                        <label for="termDefinition" class="block text-sm font-medium text-gray-700 mb-1">Definition <span class="text-red-500">*</span></label>
                        <textarea id="termDefinition" rows="3" placeholder="Provide a clear definition..." required></textarea>
                    </div>
                    <div>
                        <label for="termPronunciation" class="block text-sm font-medium text-gray-700 mb-1">Pronunciation (English approximation)</label>
                        <input type="text" id="termPronunciation" placeholder="e.g., nigzeret">
                    </div>
                    <p class="text-sm text-gray-600">Provide translations in other languages (optional):</p>
                    <div>
                        <label for="termEnglish" class="block text-sm font-medium text-gray-700 mb-1">Term (English)</label>
                        <input type="text" id="termEnglish" placeholder="e.g., Derivative">
                    </div>
                    <div>
                        <label for="termRussian" class="block text-sm font-medium text-gray-700 mb-1">Term (Russian)</label>
                        <input type="text" id="termRussian" placeholder="Производная">
                    </div>
                    <div>
                        <label for="termArabic" class="block text-sm font-medium text-gray-700 mb-1">Term (Arabic)</label>
                        <input type="text" id="termArabic" dir="rtl" placeholder="مشتقة">
                    </div>
                    <div>
                        <label for="termFrench" class="block text-sm font-medium text-gray-700 mb-1">Term (French)</label>
                        <input type="text" id="termFrench" placeholder="Dérivée">
                    </div>
                    <div>
                        <label for="termMandarin" class="block text-sm font-medium text-gray-700 mb-1">Term (Mandarin)</label>
                        <input type="text" id="termMandarin" placeholder="例如：导数">
                    </div>
                    <div>
                        <label for="termSpanish" class="block text-sm font-medium text-gray-700 mb-1">Term (Spanish)</label>
                        <input type="text" id="termSpanish" placeholder="p. ej., Derivada">
                    </div>
                    <div>
                        <label for="termHindi" class="block text-sm font-medium text-gray-700 mb-1">Term (Hindi)</label>
                        <input type="text" id="termHindi" placeholder="जैसे, व्युत्पन्न">
                    </div>
                    <div class="flex gap-4">
                        <button type="submit" id="addTermSubmitBtn">Add Term</button>
                        <button type="button" id="cancelAddTermBtn" class="btn-secondary">Cancel</button>
                    </div>
                </form>
            </div>
        </div>

        <div id="challengeGameView" class="view hidden">
            <div class="card text-center">
                <h2 class="text-3xl font-bold mb-6">Linguini Challenge! <img src="https://raw.githubusercontent.com/Ethantication/Linguini/main/WhatsApp%20Image%202025-05-19%20at%2019.42.36_a4a2cf4b.jpg" alt="Remi the Mouse" class="inline-block remi-mascot ml-2"></h2>
                <div id="challengeGameStartScreen">
                    <p class="text-lg mb-4 text-gray-700">Choose your native language to start the game:</p>
                    <select id="challengeGameLanguageSelect" class="mb-6 px-4 py-2 rounded-md border border-gray-300">
                        </select>
                    <button id="startChallengeGameButton">Start Game</button>
                </div>

                <div id="challengeGamePlayScreen" class="hidden">
                    <div class="flex justify-between items-center mb-6">
                        <div class="text-2xl font-semibold">Score: <span id="challengeGameScore">0</span></div>
                        <div class="text-2xl font-semibold text-red-500">Time: <span id="challengeGameTimer">30</span>s</div>
                    </div>
                    <p class="text-4xl font-bold mb-8" id="challengeGameTermDisplay"></p>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <button class="challenge-option-button" id="challengeOption1"></button>
                        <button class="challenge-option-button" id="challengeOption2"></button>
                    </div>
                    <p id="challengeGameFeedback" class="text-xl font-semibold mt-6 h-8"></p>
                </div>

                <div id="challengeGameOverScreen" class="hidden">
                    <h3 class="text-3xl font-bold mb-4">Game Over!</h3>
                    <p class="text-xl mb-6">Your final score: <span id="challengeFinalScore" class="font-bold text-emerald-600"></span></p>
                    <button id="playAgainChallengeButton">Play Again</button>
                </div>
            </div>
        </div>

        <div id="learnHebrewView" class="view hidden">
            <div class="card text-center">
                <h2 class="text-3xl font-bold mb-6">Learn Hebrew Vocabulary <img src="https://raw.githubusercontent.com/Ethantication/Linguini/main/WhatsApp%20Image%202025-05-19%20at%2019.42.36_a4a2cf4b.jpg" alt="Remi the Mouse" class="inline-block remi-mascot ml-2"></h2>
                <p class="text-lg mb-6 text-gray-700">
                    This section helps you master essential Hebrew terms for your academic studies at Technion.
                    Select your native language, and we'll guide you through key vocabulary with interactive games.
                </p>

                <div id="learnHebrewStartScreen">
                    <p class="text-lg mb-4 text-gray-700">Choose your native language for learning:</p>
                    <select id="learnHebrewLanguageSelect" class="mb-6 px-4 py-2 rounded-md border border-gray-300">
                        </select>
                    <button id="startLearningButton">Start Learning</button>
                </div>

                <div id="learnHebrewPlayScreen" class="hidden">
                    <div class="flex justify-between items-center w-full mb-6">
                        <div class="text-xl font-semibold">Words Mastered: <span id="masteredWordsCount">0</span></div>
                        <div class="text-xl font-semibold">Progress: <span id="learningProgress">0/0</span></div>
                    </div>
                    <div class="flex flex-col items-center mb-8">
                        <p class="text-7xl font-bold mb-2" id="hebrewTermDisplay" dir="rtl"></p>
                        <p class="text-2xl text-gray-600" id="pronunciationDisplay"></p>
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <button class="learn-hebrew-option-button" id="learnHebrewOption1"></button>
                        <button class="learn-hebrew-option-button" id="learnHebrewOption2"></button>
                    </div>
                    <p id="learnHebrewFeedback" class="text-xl font-semibold mt-6 h-8"></p>
                    <button id="learnHebrewNextWordButton" class="btn-secondary mt-4 hidden">Next Word</button>
                </div>

                <div id="learnHebrewEndScreen" class="hidden">
                    <h3 class="text-3xl font-bold mb-4">Learning Session Complete!</h3>
                    <p class="text-xl mb-6">You mastered <span id="finalMasteredCount" class="font-bold text-emerald-600"></span> words.</p>
                    <button id="startNewLearningSessionButton">Start New Session</button>
                </div>
            </div>
        </div>
    </main>

    <div class="container flex flex-wrap justify-between items-center py-4 px-6 max-w-full overflow-hidden">
    <img src="https://raw.githubusercontent.com/Ethantication/Linguini/main/image-removebg-preview%20(4).png" alt="Technion Logo" class="h-20 w-auto max-w-full">
    <img src="https://raw.githubusercontent.com/Ethantication/Linguini/main/LOGO_WIDE_Heb.png" alt="T-Hub Logo" class="h-20 w-auto max-w-full">
</div>

    <footer class="bg-gray-800 text-white p-4 text-center text-sm">
        <div class="container footer-content">
            &copy; 2025 Linguini. All rights reserved.
            <img src="https://raw.githubusercontent.com/Ethantication/Linguini/main/WhatsApp%20Image%202025-05-19%20at%2019.42.36_a4a2cf4b.jpg" alt="Remi the Mouse Footer" class="remi-mascot ml-2">
        </div>
        <div id="debugInfo" class="mt-2">
            </div>
    </footer>

    <!-- NEW HTML: The Language Proficiency Modal (Hidden by default) -->
    <div id="languageProficiencyModal">
        <h2>Become a Validator</h2>
        <p>Which language would you like to validate?</p>
        <select id="validatorLanguage">
            <option value="">--Select Language--</option>
            <option value="english">English</option>
            <option value="russian">Russian</option>
            <option value="arabic">Arabic</option>
            <option value="spanish">Spanish</option>
            <option value="mandarin">Mandarin</option>
            <option value="french">French</option>
            <option value="hindi">Hindi</option>
        </select>
        <p>On a scale of 1 to 5, how would you rate your proficiency in this language? (1 = Beginner, 5 = Native/Expert)</p>
        <input type="number" id="languageProficiency" min="1" max="5" placeholder="Enter 1-5">
        <div class="button-group">
            <button id="submitValidatorApplication">Submit Application</button>
            <button id="cancelValidatorApplication">Cancel</button>
        </div>
    </div>

    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.0/firebase-app.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.9.0/firebase-analytics.js";
        // Also import Auth and Firestore for your app's functionality
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.9.0/firebase-auth.js";
        import { getFirestore, collection, query, getDocs, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, where } from "https://www.gstatic.com/firebasejs/11.9.0/firebase-firestore.js";

        // Your web app's Firebase configuration (hardcoded directly)
        // This config should ideally come from __firebase_config global variable in Canvas env.
        // For local testing, you might hardcode it, but for Canvas, use the global variable.
        const firebaseConfig = {
            apiKey: "AIzaSyD9ijB7vwoQbog5JUCO76F5vMlvsvusodk",
            authDomain: "linguini-database.firebaseapp.com",
            projectId: "linguini-database",
            storageBucket: "linguini-database.firebasestorage.app",
            messagingSenderId: "363537478736",
            appId: "1:363537478736:web:a62c9290a9574f969d8d55",
            measurementId: "G-0D0KLF5W1V"
        };

        // Define a constant for the app ID, prioritizing __app_id from Canvas environment
        const APP_ID = typeof __app_id !== 'undefined' ? __app_id : firebaseConfig.appId;

        // Global variables for Firebase instances and user ID
        // Note: These are now `let` to allow reassignment and better reflect their dynamic nature
        let firebaseApp = null;
        let db = null;
        let auth = null;
        let userId = null;
        let isFirebaseReady = false; // Flag to ensure Firestore operations run only after auth

        // Initial application data to seed Firestore if empty
        // This data will only be used if the Firestore collections are empty.
        const initialAppData = {
            courses: [
                { id: 'c1', name: 'Calculus 1' },
                { id: 'c2', name: 'Algebra 1' },
                { id: 'c3', name: 'Intro to CS' },
                { id: 'c4', name: 'Physics 1' },
                { id: 'c5', name: 'Chemistry 1' },
                { id: 'c6', name: 'Biology 1' }
            ],
            terms: [
                // Calculus 1 Terms (c1)
                {
                    id: 't1', courseId: 'c1', definition: 'The rate at which the value of a function changes with respect to a change in the independent variable.',
                    hebrew: { text: 'נגזרת', status: 'Pending', validatedBy: null },
                    pronunciation: 'nigzeret',
                    english: { text: 'Derivative', status: 'Pending', validatedBy: null },
                    russian: { text: 'Производная', status: 'Pending', validatedBy: null },
                    arabic: { text: 'مشتقة', status: 'Pending', validatedBy: null },
                    french: { text: 'Dérivée', status: 'Pending', validatedBy: null },
                    mandarin: { text: '导数', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Derivada', status: 'Pending', validatedBy: null },
                    hindi: { text: 'व्युत्पन्न', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't2', courseId: 'c1', definition: 'A mathematical object that can be interpreted as an area, a generalization of mass, or the total change of a quantity whose rate of change is known.',
                    hebrew: { text: 'אינטגרל', status: 'Pending', validatedBy: null },
                    pronunciation: 'integral',
                    english: { text: 'Integral', status: 'Pending', validatedBy: null },
                    russian: { text: 'Интеграл', status: 'Pending', validatedBy: null },
                    arabic: { text: 'تكامل', status: 'Pending', validatedBy: null },
                    french: { text: 'Intégrale', status: 'Pending', validatedBy: null },
                    mandarin: { text: '积分', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Integral', status: 'Pending', validatedBy: null },
                    hindi: { text: 'अभिन्न', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't12', courseId: 'c1', definition: 'A limit of a function in calculus that defines the value a function approaches as the input (or index) approaches some value.',
                    hebrew: { text: 'גבול', status: 'Pending', validatedBy: null },
                    pronunciation: 'gvul',
                    english: { text: 'Limit', status: 'Pending', validatedBy: null },
                    russian: { text: 'Предел', status: 'Pending', validatedBy: null },
                    arabic: { text: 'نهاية', status: 'Pending', validatedBy: null },
                    french: { text: 'Limite', status: 'Pending', validatedBy: null },
                    mandarin: { text: '极限', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Límite', status: 'Pending', validatedBy: null },
                    hindi: { text: 'सीमा', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't21', courseId: 'c1', definition: 'The inverse operation of differentiation, used to find functions whose derivative is known.',
                    hebrew: { text: 'אנטי-נגזרת', status: 'Pending', validatedBy: null },
                    pronunciation: 'anti-nigzeret',
                    english: { text: 'Antiderivative', status: 'Pending', validatedBy: null },
                    russian: { text: 'Первообразная', status: 'Pending', validatedBy: null },
                    arabic: { text: 'المشتقة العكسية', status: 'Pending', validatedBy: null },
                    french: { text: 'Primitive', status: 'Pending', validatedBy: null },
                    mandarin: { text: '反导数', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Antiderivada', status: 'Pending', validatedBy: null },
                    hindi: { text: 'प्रति-अवकalaj', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c1_5', courseId: 'c1', definition: 'The concept of continuity is fundamental to calculus and describes functions that do not have abrupt changes in value.',
                    hebrew: { text: 'רציפות', status: 'Pending', validatedBy: null },
                    pronunciation: 'retsifut',
                    english: { text: 'Continuity', status: 'Pending', validatedBy: null },
                    russian: { text: 'Непрерывность', status: 'Pending', validatedBy: null },
                    arabic: { text: 'استمرارية', status: 'Pending', validatedBy: null },
                    french: { text: 'Continuité', status: 'Pending', validatedBy: null },
                    mandarin: { text: '连续性', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Continuidad', status: 'Pending', validatedBy: null },
                    hindi: { text: 'निरंतरता', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c1_6', courseId: 'c1', definition: 'The process of finding the maximum or minimum value of a function.',
                    hebrew: { text: 'אופטימיזציה', status: 'Pending', validatedBy: null },
                    pronunciation: 'optimitzatsya',
                    english: { text: 'Optimization', status: 'Pending', validatedBy: null },
                    russian: { text: 'Оптимизация', status: 'Pending', validatedBy: null },
                    arabic: { text: 'تحسين', status: 'Pending', validatedBy: null },
                    french: { text: 'Optimisation', status: 'Pending', validatedBy: null },
                    mandarin: { text: '优化', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Optimización', status: 'Pending', validatedBy: null },
                    hindi: { text: 'अनुकूलन', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c1_7', courseId: 'c1', definition: 'The set of all points where a function is defined.',
                    hebrew: { text: 'תחום הגדרה', status: 'Pending', validatedBy: null },
                    pronunciation: 'tchum hagdara',
                    english: { text: 'Domain', status: 'Pending', validatedBy: null },
                    russian: { text: 'Область определения', status: 'Pending', validatedBy: null },
                    arabic: { text: 'مجال التعريف', status: 'Pending', validatedBy: null },
                    french: { text: 'Domaine de définition', status: 'Pending', validatedBy: null },
                    mandarin: { text: '定义域', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Dominio', status: 'Pending', validatedBy: null },
                    hindi: { text: 'डोमेन', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c1_8', courseId: 'c1', definition: 'The set of all possible output values of a function.',
                    hebrew: { text: 'טווח', status: 'Pending', validatedBy: null },
                    pronunciation: 'tvach',
                    english: { text: 'Range', status: 'Pending', validatedBy: null },
                    russian: { text: 'Область значений', status: 'Pending', validatedBy: null },
                    arabic: { text: 'مدى', status: 'Pending', validatedBy: null },
                    french: { text: 'Image', status: 'Pending', validatedBy: null },
                    mandarin: { text: '值域', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Rango', status: 'Pending', validatedBy: null },
                    hindi: { text: 'श्रेणी', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c1_9', courseId: 'c1', definition: 'A vertical asymptote is a vertical line that the graph of a function approaches but never touches as the input value approaches a certain number.',
                    hebrew: { text: 'אסימפטוטה אנכית', status: 'Pending', validatedBy: null },
                    pronunciation: 'asimptota anachit',
                    english: { text: 'Vertical Asymptote', status: 'Pending', validatedBy: null },
                    russian: { text: 'Вертикальная асимптота', status: 'Pending', validatedBy: null },
                    arabic: { text: 'مقارب رأسي', status: 'Pending', validatedBy: null },
                    french: { text: 'Asymptote verticale', status: 'Pending', validatedBy: null },
                    mandarin: { text: '垂直渐近线', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Asíntota vertical', status: 'Pending', validatedBy: null },
                    hindi: { text: 'ऊर्ध्वाधर स्पर्शोन्मुख', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c1_10', courseId: 'c1', definition: 'A horizontal asymptote is a horizontal line that the graph of a function approaches as the input value tends towards positive or negative infinity.',
                    hebrew: { text: 'אסימפטוטה אופקית', status: 'Pending', validatedBy: null },
                    pronunciation: 'asimptota ofkit',
                    english: { text: 'Horizontal Asymptote', status: 'Pending', validatedBy: null },
                    russian: { text: 'Горизонтальная асимптота', status: 'Pending', validatedBy: null },
                    arabic: { text: 'مقارب أفقي', status: 'Pending', validatedBy: null },
                    french: { text: 'Asymptote horizontale', status: 'Pending', validatedBy: null },
                    mandarin: { text: '水平渐近线', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Asíntota horizontal', status: 'Pending', validatedBy: null },
                    hindi: { text: 'क्षैतिज स्पर्शोन्मुख', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c1_11', courseId: 'c1', definition: 'The definite integral can be interpreted as the area of the region bounded by the graph of a function, the x-axis, and vertical lines.',
                    hebrew: { text: 'אינטגרל מסוים', status: 'Pending', validatedBy: null },
                    pronunciation: 'integral meyuham',
                    english: { text: 'Definite Integral', status: 'Pending', validatedBy: null },
                    russian: { text: 'Определенный интеграл', status: 'Pending', validatedBy: null },
                    arabic: { text: 'تكامل محدد', status: 'Pending', validatedBy: null },
                    french: { text: 'Intégrale definida', status: 'Pending', validatedBy: null },
                    mandarin: { text: '定积分', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Integral definida', status: 'Pending', validatedBy: null },
                    hindi: { text: 'निश्चित समाकल', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c1_12', courseId: 'c1', definition: 'A tangent line to a curve at a given point is a straight line that "just touches" the curve at that point.',
                    hebrew: { text: 'קו משיק', status: 'Pending', validatedBy: null },
                    pronunciation: 'kav mashik',
                    english: { text: 'Tangent Line', status: 'Pending', validatedBy: null },
                    russian: { text: 'Касательная', status: 'Pending', validatedBy: null },
                    arabic: { text: 'خط مماس', status: 'Pending', validatedBy: null },
                    french: { text: 'Tangente', status: 'Pending', validatedBy: null },
                    mandarin: { text: '切线', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Recta tangente', status: 'Pending', validatedBy: null },
                    hindi: { text: 'स्पर्श रेखा', status: 'Pending', validatedBy: null }
                },

                // Algebra 1 Terms (c2)
                {
                    id: 't3', courseId: 'c2', definition: 'A rectangular array of numbers, symbols, or expressions, arranged in rows and columns.',
                    hebrew: { text: 'מטריצה', status: 'Pending', validatedBy: null },
                    pronunciation: 'matritza',
                    english: { text: 'Matrix', status: 'Pending', validatedBy: null },
                    russian: { text: 'Матрица', status: 'Pending', validatedBy: null },
                    arabic: { text: 'مصفوفة', status: 'Pending', validatedBy: null },
                    french: { text: 'Matrice', status: 'Pending', validatedBy: null },
                    mandarin: { text: '矩阵', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Matriz', status: 'Pending', validatedBy: null },
                    hindi: { text: 'आव्यूह', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't13', courseId: 'c2', definition: 'A scalar value that is a function of the entries of a square matrix.',
                    hebrew: { text: 'דטרמיננטה', status: 'Pending', validatedBy: null },
                    pronunciation: 'determinanta',
                    english: { text: 'Determinant', status: 'Pending', validatedBy: null },
                    russian: { text: 'Определитель', status: 'Pending', validatedBy: null },
                    arabic: { text: 'محدد', status: 'Pending', validatedBy: null },
                    french: { text: 'Déterminant', status: 'Pending', validatedBy: null },
                    mandarin: { text: '行列式', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Determinante', status: 'Pending', validatedBy: null },
                    hindi: { text: 'निर्धारक', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't22', courseId: 'c2', definition: 'A vector space is a set of objects, called vectors, on which two operations are defined: vector addition and scalar multiplication.',
                    hebrew: { text: 'מרחב וקטורי', status: 'Pending', validatedBy: null },
                    pronunciation: 'merchav vektori',
                    english: { text: 'Vector Space', status: 'Pending', validatedBy: null },
                    russian: { text: 'Векторное пространство', status: 'Pending', validatedBy: null },
                    arabic: { text: 'فضاء متجه', status: 'Pending', validatedBy: null },
                    french: { text: 'Espace vectoriel', status: 'Pending', validatedBy: null },
                    mandarin: { text: '向量空间', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Espacio vectorial', status: 'Pending', validatedBy: null },
                    hindi: { text: 'सदिश समष्टि', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c2_4', courseId: 'c2', definition: 'An equation containing variables raised to the first power, with no products of variables.',
                    hebrew: { text: 'משוואה ליניארית', status: 'Pending', validatedBy: null },
                    pronunciation: 'mishvaah linearit',
                    english: { text: 'Linear Equation', status: 'Pending', validatedBy: null },
                    russian: { text: 'Линейное уравнение', status: 'Pending', validatedBy: null },
                    arabic: { text: 'معادلة خطية', status: 'Pending', validatedBy: null },
                    french: { text: 'Équation linéaire', status: 'Pending', validatedBy: null },
                    mandarin: { text: '线性方程', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Ecuación lineal', status: 'Pending', validatedBy: null },
                    hindi: { text: 'रेखीय समीकरण', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c2_5', courseId: 'c2', definition: 'A collection of linear equations involving the same set of variables.',
                    hebrew: { text: 'מערכת משוואות', status: 'Pending', validatedBy: null },
                    pronunciation: 'maarechet mishvaot',
                    english: { text: 'System of Equations', status: 'Pending', validatedBy: null },
                    russian: { text: 'Система уравнений', status: 'Pending', validatedBy: null },
                    arabic: { text: 'نظام معادلات', status: 'Pending', validatedBy: null },
                    french: { text: 'Système d\'équations', status: 'Pending', validatedBy: null },
                    mandarin: { text: '方程组', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Sistema de ecuaciones', status: 'Pending', validatedBy: null },
                    hindi: { text: 'समीकरणों का तंत्र', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c2_6', courseId: 'c2', definition: 'A number that, when multiplied by another number, yields 1.',
                    hebrew: { text: 'הופכי', status: 'Pending', validatedBy: null },
                    pronunciation: 'hofchi',
                    english: { text: 'Reciprocal', status: 'Pending', validatedBy: null },
                    russian: { text: 'Взаимный', status: 'Pending', validatedBy: null },
                    arabic: { text: 'מقلوب', status: 'Pending', validatedBy: null },
                    french: { text: 'Inverse', status: 'Pending', validatedBy: null },
                    mandarin: { text: '倒数', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Recíproco', status: 'Pending', validatedBy: null },
                    hindi: { text: 'व्युत्क्रम', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c2_7', courseId: 'c2', definition: 'A value that describes the steepness and direction of a line.',
                    hebrew: { text: 'שיפוע', status: 'Pending', validatedBy: null },
                    pronunciation: 'shipuach',
                    english: { text: 'Slope', status: 'Pending', validatedBy: null },
                    russian: { text: 'Наклон', status: 'Pending', validatedBy: null },
                    arabic: { text: 'ميل', status: 'Pending', validatedBy: null },
                    french: { text: 'Pente', status: 'Pending', validatedBy: null },
                    mandarin: { text: '斜率', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Pendiente', status: 'Pending', validatedBy: null },
                    hindi: { text: 'ढलान', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c2_8', courseId: 'c2', definition: 'A mathematical statement that two expressions are equal.',
                    hebrew: { text: 'שוויון', status: 'Pending', validatedBy: null },
                    pronunciation: 'shivyon',
                    english: { text: 'Equality', status: 'Pending', validatedBy: null },
                    russian: { text: 'Равенство', status: 'Pending', validatedBy: null },
                    arabic: { text: 'مساواة', status: 'Pending', validatedBy: null },
                    french: { text: 'Égalité', status: 'Pending', validatedBy: null },
                    mandarin: { text: '相等', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Igualdad', status: 'Pending', validatedBy: null },
                    hindi: { text: 'समानता', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c2_9', courseId: 'c2', definition: 'A number that can be expressed as a fraction p/q, where p and q are integers and q is not zero.',
                    hebrew: { text: 'מספר רציונלי', status: 'Pending', validatedBy: null },
                    pronunciation: 'mispar ratsyionali',
                    english: { text: 'Rational Number', status: 'Pending', validatedBy: null },
                    russian: { text: 'Рациональное число', status: 'Pending', validatedBy: null },
                    arabic: { text: 'عدد نسبي', status: 'Pending', validatedBy: null },
                    french: { text: 'Nombre rationnel', status: 'Pending', validatedBy: null },
                    mandarin: { text: '有理数', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Número racional', status: 'Pending', validatedBy: null },
                    hindi: { text: 'परिमेय संख्या', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c2_10', courseId: 'c2', definition: 'A symbol that represents a quantity in a mathematical expression, usually a letter.',
                    hebrew: { text: 'נעלם', status: 'Pending', validatedBy: null },
                    pronunciation: 'naalam',
                    english: { text: 'Unknown (variable)', status: 'Pending', validatedBy: null },
                    russian: { text: 'Неизвестная', status: 'Pending', validatedBy: null },
                    arabic: { text: 'مجهول', status: 'Pending', validatedBy: null },
                    french: { text: 'Inconnue', status: 'Pending', validatedBy: null },
                    mandarin: { text: '未知数', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Incógnita', status: 'Pending', validatedBy: null },
                    hindi: { text: 'अज्ञात', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c2_11', courseId: 'c2', definition: 'A number that, when multiplied by a matrix, scales its rows or columns.',
                    hebrew: { text: 'סקאלר', status: 'Pending', validatedBy: null },
                    pronunciation: 'skalar',
                    english: { text: 'Scalar', status: 'Pending', validatedBy: null },
                    russian: { text: 'Скаляр', status: 'Pending', validatedBy: null },
                    arabic: { text: 'كمية قياسية', status: 'Pending', validatedBy: null },
                    french: { text: 'Scalaire', status: 'Pending', validatedBy: null },
                    mandarin: { text: '标量', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Escalar', status: 'Pending', validatedBy: null },
                    hindi: { text: 'अदिश', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c2_12', courseId: 'c2', definition: 'A set of vectors that are linearly independent and span the entire vector space.',
                    hebrew: { text: 'בסיס', status: 'Pending', validatedBy: null },
                    pronunciation: 'basis',
                    english: { text: 'Basis', status: 'Pending', validatedBy: null },
                    russian: { text: 'Базис', status: 'Pending', validatedBy: null },
                    arabic: { text: 'أساس', status: 'Pending', validatedBy: null },
                    french: { text: 'Base', status: 'Pending', validatedBy: null },
                    mandarin: { text: '基', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Base', status: 'Pending', validatedBy: null },
                    hindi: { text: 'आधार', status: 'Pending', validatedBy: null }
                },

                // Intro to CS Terms (c3)
                {
                    id: 't4', courseId: 'c3', definition: 'A named storage location that contains a value.',
                    hebrew: { text: 'משתנה', status: 'Pending', validatedBy: null },
                    pronunciation: 'mishtaneh',
                    english: { text: 'Variable', status: 'Pending', validatedBy: null },
                    russian: { text: 'Переменная', status: 'Pending', validatedBy: null },
                    arabic: { text: 'متغير', status: 'Pending', validatedBy: null },
                    french: { text: 'Variable', status: 'Pending', validatedBy: null },
                    mandarin: { text: '变量', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Variable', status: 'Pending', validatedBy: null },
                    hindi: { text: 'चर', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't14', courseId: 'c3', definition: 'A step-by-step procedure for solving a problem or accomplishing a task.',
                    hebrew: { text: 'אלגוריתם', status: 'Pending', validatedBy: null },
                    pronunciation: 'algoritm',
                    english: { text: 'Algorithm', status: 'Pending', validatedBy: null },
                    russian: { text: 'Алгоритм', status: 'Pending', validatedBy: null },
                    arabic: { text: 'خوارزمية', status: 'Pending', validatedBy: null },
                    french: { text: 'Algorithme', status: 'Pending', validatedBy: null },
                    mandarin: { text: '算法', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Algoritmo', status: 'Pending', validatedBy: null },
                    hindi: { text: 'एल्गोरिथम', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't23', courseId: 'c3', definition: 'A sequence of characters, used for text in programming languages.',
                    hebrew: { text: 'מחרוזת', status: 'Pending', validatedBy: null },
                    pronunciation: 'machrozhet',
                    english: { text: 'String', status: 'Pending', validatedBy: null },
                    russian: { text: 'Строка', status: 'Pending', validatedBy: null },
                    arabic: { text: 'سلسلة', status: 'Pending', validatedBy: null },
                    french: { text: 'Chaîne de caractères', status: 'Pending', validatedBy: null },
                    mandarin: { text: '字符串', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Cadena', status: 'Pending', validatedBy: null },
                    hindi: { text: 'स्ट्रिंग', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't27', courseId: 'c3', definition: 'A method for storing and organizing data in a computer\'s memory or disk.',
                    hebrew: { text: 'מבנה נתונים', status: 'Pending', validatedBy: null },
                    pronunciation: 'mivne netunim',
                    english: { text: 'Data Structure', status: 'Pending', validatedBy: null },
                    russian: { text: 'Структура данных', status: 'Pending', validatedBy: null },
                    arabic: { text: 'هيكل البيانات', status: 'Pending', validatedBy: null },
                    french: { text: 'Structure de données', status: 'Pending', validatedBy: null },
                    mandarin: { text: '数据结构', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Estructura de datos', status: 'Pending', validatedBy: null },
                    hindi: { text: 'डेटा संरचना', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c3_5', courseId: 'c3', definition: 'A set of rules for writing code that a computer can understand.',
                    hebrew: { text: 'שפת תכנות', status: 'Pending', validatedBy: null },
                    pronunciation: 'sfat tichnut',
                    english: { text: 'Programming Language', status: 'Pending', validatedBy: null },
                    russian: { text: 'Язык программирования', status: 'Pending', validatedBy: null },
                    arabic: { text: 'لغة برمجة', status: 'Pending', validatedBy: null },
                    french: { text: 'Langage de programmation', status: 'Pending', validatedBy: null },
                    mandarin: { text: '编程语言', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Lenguaje de programación', status: 'Pending', validatedBy: null },
                    hindi: { text: 'प्रोग्रामिंग भाषा', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c3_6', courseId: 'c3', definition: 'A logical concept in programming that checks if a condition is true or false.',
                    hebrew: { text: 'תנאי', status: 'Pending', validatedBy: null },
                    pronunciation: 'tnai',
                    english: { text: 'Condition', status: 'Pending', validatedBy: null },
                    russian: { text: 'Условие', status: 'Pending', validatedBy: null },
                    arabic: { text: 'شرط', status: 'Pending', validatedBy: null },
                    french: { text: 'Condition', status: 'Pending', validatedBy: null },
                    mandarin: { text: '条件', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Condición', status: 'Pending', validatedBy: null },
                    hindi: { text: 'शर्त', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c3_7', courseId: 'c3', definition: 'A block of code that is designed to perform a specific task and can be reused.',
                    hebrew: { text: 'פונקציה', status: 'Pending', validatedBy: null },
                    pronunciation: 'funktsia',
                    english: { text: 'Function', status: 'Pending', validatedBy: null },
                    russian: { text: 'Функция', status: 'Pending', validatedBy: null },
                    arabic: { text: 'دالة', status: 'Pending', validatedBy: null },
                    french: { text: 'Fonction', status: 'Pending', validatedBy: null },
                    mandarin: { text: '函数', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Función', status: 'Pending', validatedBy: null },
                    hindi: { text: 'फ़ंक्शन', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c3_8', courseId: 'c3', definition: 'A control flow statement that allows code to be executed repeatedly based on a condition.',
                    hebrew: { text: 'לולאה', status: 'Pending', validatedBy: null },
                    pronunciation: 'lulaa',
                    english: { text: 'Loop', status: 'Pending', validatedBy: null },
                    russian: { text: 'Цикл', status: 'Pending', validatedBy: null },
                    arabic: { text: 'حلقة', status: 'Pending', validatedBy: null },
                    french: { text: 'Boucle', status: 'Pending', validatedBy: null },
                    mandarin: { text: '循环', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Bucle', status: 'Pending', validatedBy: null },
                    hindi: { text: 'लूप', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c3_9', courseId: 'c3', definition: 'A value that can be either true or false.',
                    hebrew: { text: 'בוליאני', status: 'Pending', validatedBy: null },
                    pronunciation: 'buliani',
                    english: { text: 'Boolean', status: 'Pending', validatedBy: null },
                    russian: { text: 'Булево значение', status: 'Pending', validatedBy: null },
                    arabic: { text: 'منطقي', status: 'Pending', validatedBy: null },
                    french: { text: 'Booléen', status: 'Pending', validatedBy: null },
                    mandarin: { text: '布尔值', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Booleano', status: 'Pending', validatedBy: null },
                    hindi: { text: 'बूलियन', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c3_10', courseId: 'c3', definition: 'A piece of data or value that can be assigned to a variable or passed as an argument.',
                    hebrew: { text: 'ערך', status: 'Pending', validatedBy: null },
                    pronunciation: 'erech',
                    english: { text: 'Value', status: 'Pending', validatedBy: null },
                    russian: { text: 'Значение', status: 'Pending', validatedBy: null },
                    arabic: { text: 'قيمة', status: 'Pending', validatedBy: null },
                    french: { text: 'Valeur', status: 'Pending', validatedBy: null },
                    mandarin: { text: '值', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Valor', status: 'Pending', validatedBy: null },
                    hindi: { text: 'मूल्य', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c3_11', courseId: 'c3', definition: 'A predefined set of rules that dictate how data can be exchanged between computers.',
                    hebrew: { text: 'פרוטוקול', status: 'Pending', validatedBy: null },
                    pronunciation: 'protokol',
                    english: { text: 'Protocol', status: 'Pending', validatedBy: null },
                    russian: { text: 'Протокол', status: 'Pending', validatedBy: null },
                    arabic: { text: 'بروتوكول', status: 'Pending', validatedBy: null },
                    french: { text: 'Protocole', status: 'Pending', validatedBy: null },
                    mandarin: { text: '协议', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Protocolo', status: 'Pending', validatedBy: null },
                    hindi: { text: 'प्रोटोकॉल', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c3_12', courseId: 'c3', definition: 'A software program that helps to manage and coordinate computer hardware and software resources.',
                    hebrew: { text: 'מערכת הפעלה', status: 'Pending', validatedBy: null },
                    pronunciation: 'maarechet hafaala',
                    english: { text: 'Operating System', status: 'Pending', validatedBy: null },
                    russian: { text: 'Операционная система', status: 'Pending', validatedBy: null },
                    arabic: { text: 'نظام تشغيل', status: 'Pending', validatedBy: null },
                    french: { text: 'Système d\'exploitation', status: 'Pending', validatedBy: null },
                    mandarin: { text: '操作系统', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Sistema operativo', status: 'Pending', validatedBy: null },
                    hindi: { text: 'ऑपरेटिंग सिस्टम', status: 'Pending', validatedBy: null }
                },

                // Physics 1 Terms (c4)
                {
                    id: 't5', courseId: 'c4', definition: 'The force that causes objects to fall toward the center of the Earth.',
                    hebrew: { text: 'כוח כבידה', status: 'Pending', validatedBy: null },
                    pronunciation: 'koach kfida',
                    english: { text: 'Gravity', status: 'Pending', validatedBy: null },
                    russian: { text: 'Гравитация', status: 'Pending', validatedBy: null },
                    arabic: { text: 'الجاذبية', status: 'Pending', validatedBy: null },
                    french: { text: 'Gravité', status: 'Pending', validatedBy: null },
                    mandarin: { text: '重力', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Gravedad', status: 'Pending', validatedBy: null },
                    hindi: { text: 'गुरुत्वाकर्षण', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't15', courseId: 'c4', definition: 'The rate at which an object changes its velocity.',
                    hebrew: { text: 'תאוצה', status: 'Pending', validatedBy: null },
                    pronunciation: 'teutza',
                    english: { text: 'Acceleration', status: 'Pending', validatedBy: null },
                    russian: { text: 'Ускорение', status: 'Pending', validatedBy: null },
                    arabic: { text: 'تسارع', status: 'Pending', validatedBy: null },
                    french: { text: 'Accélération', status: 'Pending', validatedBy: null },
                    mandarin: { text: '加速度', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Aceleración', status: 'Pending', validatedBy: null },
                    hindi: { text: 'त्वरण', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't24', courseId: 'c4', definition: 'The study of motion and its causes.',
                    hebrew: { text: 'מכניקה', status: 'Pending', validatedBy: null },
                    pronunciation: 'mechanika',
                    english: { text: 'Mechanics', status: 'Pending', validatedBy: null },
                    russian: { text: 'Механика', status: 'Pending', validatedBy: null },
                    arabic: { text: 'الميكانيكا', status: 'Pending', validatedBy: null },
                    french: { text: 'Mécanique', status: 'Pending', validatedBy: null },
                    mandarin: { text: '力学', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Mecánica', status: 'Pending', validatedBy: null },
                    hindi: { text: 'यांत्रिकी', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c4_4', courseId: 'c4', definition: 'The product of an object\'s mass and its velocity.',
                    hebrew: { text: 'תנע', status: 'Pending', validatedBy: null },
                    pronunciation: 'tena',
                    english: { text: 'Momentum', status: 'Pending', validatedBy: null },
                    russian: { text: 'Импульс', status: 'Pending', validatedBy: null },
                    arabic: { text: 'الزخم', status: 'Pending', validatedBy: null },
                    french: { text: 'Quantité de mouvement', status: 'Pending', validatedBy: null },
                    mandarin: { text: '动量', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Momento lineal', status: 'Pending', validatedBy: null },
                    hindi: { text: 'संवेग', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c4_5', courseId: 'c4', definition: 'The capacity to do work.',
                    hebrew: { text: 'אנרגיה', status: 'Pending', validatedBy: null },
                    pronunciation: 'energiyah',
                    english: { text: 'Energy', status: 'Pending', validatedBy: null },
                    russian: { text: 'Энергия', status: 'Pending', validatedBy: null },
                    arabic: { text: 'طاقة', status: 'Pending', validatedBy: null },
                    french: { text: 'Énergie', status: 'Pending', validatedBy: null },
                    mandarin: { text: '能量', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Energía', status: 'Pending', validatedBy: null },
                    hindi: { text: 'ऊर्जा', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c4_6', courseId: 'c4', definition: 'The change in an object\'s position.',
                    hebrew: { text: 'העתק', status: 'Pending', validatedBy: null },
                    pronunciation: 'heteq',
                    english: { text: 'Displacement', status: 'Pending', validatedBy: null },
                    russian: { text: 'Смещение', status: 'Pending', validatedBy: null },
                    arabic: { text: 'إزاحة', status: 'Pending', validatedBy: null },
                    french: { text: 'Déplacement', status: 'Pending', validatedBy: null },
                    mandarin: { text: '位移', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Desplazamiento', status: 'Pending', validatedBy: null },
                    hindi: { text: 'विस्थापन', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c4_7', courseId: 'c4', definition: 'The resistance of an object to any change in its state of motion.',
                    hebrew: { text: 'אינרציה', status: 'Pending', validatedBy: null },
                    pronunciation: 'inertzia',
                    english: { text: 'Inertia', status: 'Pending', validatedBy: null },
                    russian: { text: 'Инерция', status: 'Pending', validatedBy: null },
                    arabic: { text: 'قصور ذاتي', status: 'Pending', validatedBy: null },
                    french: { text: 'Inertie', status: 'Pending', validatedBy: null },
                    mandarin: { text: '惯性', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Inercia', status: 'Pending', validatedBy: null },
                    hindi: { text: 'जड़ता', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c4_8', courseId: 'c4', definition: 'The rate at which work is done.',
                    hebrew: { text: 'הספק', status: 'Pending', validatedBy: null },
                    pronunciation: 'hespeq',
                    english: { text: 'Power', status: 'Pending', validatedBy: null },
                    russian: { text: 'Мощность', status: 'Pending', validatedBy: null },
                    arabic: { text: 'طاقة (قوة)', status: 'Pending', validatedBy: null },
                    french: { text: 'Puissance', status: 'Pending', validatedBy: null },
                    mandarin: { text: '功率', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Potencia', status: 'Pending', validatedBy: null },
                    hindi: { text: 'शक्ति', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c4_9', courseId: 'c4', definition: 'A push or a pull upon an object resulting from the object\'s interaction with another object.',
                    hebrew: { text: 'כוח', status: 'Pending', validatedBy: null },
                    pronunciation: 'koach',
                    english: { text: 'Force', status: 'Pending', validatedBy: null },
                    russian: { text: 'Сила', status: 'Pending', validatedBy: null },
                    arabic: { text: 'قوة', status: 'Pending', validatedBy: null },
                    french: { text: 'Force', status: 'Pending', validatedBy: null },
                    mandarin: { text: '力', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Fuerza', status: 'Pending', validatedBy: null },
                    hindi: { text: 'बल', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c4_10', courseId: 'c4', definition: 'The resistance to motion caused by the contact of two surfaces.',
                    hebrew: { text: 'חיכוך', status: 'Pending', validatedBy: null },
                    pronunciation: 'chikuch',
                    english: { text: 'Friction', status: 'Pending', validatedBy: null },
                    russian: { text: 'Трение', status: 'Pending', validatedBy: null },
                    arabic: { text: 'احت frictionكاك', status: 'Pending', validatedBy: null },
                    french: { text: 'Frottement', status: 'Pending', validatedBy: null },
                    mandarin: { text: '摩擦力', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Fricción', status: 'Pending', validatedBy: null },
                    hindi: { text: 'घर्षण', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c4_11', courseId: 'c4', definition: 'The total energy of an isolated system remains constant; it can only transform from one form to another.',
                    hebrew: { text: 'שימור אנרגיה', status: 'Pending', validatedBy: null },
                    pronunciation: 'shimur energiyah',
                    english: { text: 'Conservation of Energy', status: 'Pending', validatedBy: null },
                    russian: { text: 'Сохранение энергии', status: 'Pending', validatedBy: null },
                    arabic: { text: 'حفظ الطاقة', status: 'Pending', validatedBy: null },
                    french: { text: 'Conservation de l\'énergie', status: 'Pending', validatedBy: null },
                    mandarin: { text: '能量守恒', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Conservación de la energía', status: 'Pending', validatedBy: null },
                    hindi: { text: 'ऊर्जा का संरक्षण', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c4_12', courseId: 'c4', definition: 'The path taken by an object thrown or projected into the air, subject to the force of gravity.',
                    hebrew: { text: 'מסלול בליסטי', status: 'Pending', validatedBy: null },
                    pronunciation: 'maslul balisti',
                    english: { text: 'Projectile Motion', status: 'Pending', validatedBy: null },
                    russian: { text: 'Баллистическое движение', status: 'Pending', validatedBy: null },
                    arabic: { text: 'حركة المقذوفات', status: 'Pending', validatedBy: null },
                    french: { text: 'Mouvement de projectile', status: 'Pending', validatedBy: null },
                    mandarin: { text: '抛物运动', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Movimiento parabólico', status: 'Pending', validatedBy: null },
                    hindi: { text: 'प्रक्षेप्य गति', status: 'Pending', validatedBy: null }
                },

                // Chemistry 1 Terms (c5)
                {
                    id: 't6', courseId: 'c5', definition: 'The smallest unit of matter that retains an element\'s chemical identity.',
                    hebrew: { text: 'אטום', status: 'Pending', validatedBy: null },
                    pronunciation: 'atom',
                    english: { text: 'Atom', status: 'Pending', validatedBy: null },
                    russian: { text: 'Атом', status: 'Pending', validatedBy: null },
                    arabic: { text: 'ذرة', status: 'Pending', validatedBy: null },
                    french: { text: 'Atome', status: 'Pending', validatedBy: null },
                    mandarin: { text: '原子', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Átomo', status: 'Pending', validatedBy: null },
                    hindi: { text: 'परमाणु', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't25', courseId: 'c5', definition: 'A substance that produces hydrogen ions (H+) in solution and can accept electrons.',
                    hebrew: { text: 'חומצה', status: 'Pending', validatedBy: null },
                    pronunciation: 'chumtza',
                    english: { text: 'Acid', status: 'Pending', validatedBy: null },
                    russian: { text: 'Кислота', status: 'Pending', validatedBy: null },
                    arabic: { text: 'حمض', status: 'Pending', validatedBy: null },
                    french: { text: 'Acide', status: 'Pending', validatedBy: null },
                    mandarin: { text: '酸', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Ácido', status: 'Pending', validatedBy: null },
                    hindi: { text: 'अम्ल', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c5_3', courseId: 'c5', definition: 'A substance that can neutralize acids by reacting with hydrogen ions (H+) in solution.',
                    hebrew: { text: 'בסיס', status: 'Pending', validatedBy: null },
                    pronunciation: 'basis',
                    english: { text: 'Base', status: 'Pending', validatedBy: null },
                    russian: { text: 'Основание', status: 'Pending', validatedBy: null },
                    arabic: { text: 'قاعدة', status: 'Pending', validatedBy: null },
                    french: { text: 'Base', status: 'Pending', validatedBy: null },
                    mandarin: { text: '碱', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Base', status: 'Pending', validatedBy: null },
                    hindi: { text: 'आधार', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c5_4', courseId: 'c5', definition: 'A process that involves rearrangement of the molecular or ionic structure of a substance, as distinct from a change in physical form or a nuclear reaction.',
                    hebrew: { text: 'תגובה כימית', status: 'Pending', validatedBy: null },
                    pronunciation: 'tguva chimit',
                    english: { text: 'Chemical Reaction', status: 'Pending', validatedBy: null },
                    russian: { text: 'Химическая реакция', status: 'Pending', validatedBy: null },
                    arabic: { text: 'تفاعل كيميائي', status: 'Pending', validatedBy: null },
                    french: { text: 'Réaction chimique', status: 'Pending', validatedBy: null },
                    mandarin: { text: '化学反应', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Reacción química', status: 'Pending', validatedBy: null },
                    hindi: { text: 'रासायनिक अभिक्रिया', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c5_5', courseId: 'c5', definition: 'A substance formed when two or more chemical elements are chemically bonded together.',
                    hebrew: { text: 'תרכובת', status: 'Pending', validatedBy: null },
                    pronunciation: 'tirkovet',
                    english: { text: 'Compound', status: 'Pending', validatedBy: null },
                    russian: { text: 'Соединение', status: 'Pending', validatedBy: null },
                    arabic: { text: 'مركب', status: 'Pending', validatedBy: null },
                    french: { text: 'Composé', status: 'Pending', validatedBy: null },
                    mandarin: { text: '化合物', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Compuesto', status: 'Pending', validatedBy: null },
                    hindi: { text: 'यौगिक', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c5_6', courseId: 'c5', definition: 'A table that organizes all of the known chemical elements in order of increasing atomic number.',
                    hebrew: { text: 'טבלה מחזורית', status: 'Pending', validatedBy: null },
                    pronunciation: 'tavla machzorit',
                    english: { text: 'Periodic Table', status: 'Pending', validatedBy: null },
                    russian: { text: 'Периодическая таблица', status: 'Pending', validatedBy: null },
                    arabic: { text: 'الجدول الدوري', status: 'Pending', validatedBy: null },
                    french: { text: 'Tableau périodique', status: 'Pending', validatedBy: null },
                    mandarin: { text: '元素周期表', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Tabla periódica', status: 'Pending', validatedBy: null },
                    hindi: { text: 'आवर्त सारणी', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c5_7', courseId: 'c5', definition: 'The smallest particle of a substance that retains its chemical and physical properties and is composed of two or more atoms held together by chemical bonds.',
                    hebrew: { text: 'מולקולה', status: 'Pending', validatedBy: null },
                    pronunciation: 'molekula',
                    english: { text: 'Molecule', status: 'Pending', validatedBy: null },
                    russian: { text: 'Молекула', status: 'Pending', validatedBy: null },
                    arabic: { text: 'جزيء', status: 'Pending', validatedBy: null },
                    french: { text: 'Molécule', status: 'Pending', validatedBy: null },
                    mandarin: { text: '分子', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Molécula', status: 'Pending', validatedBy: null },
                    hindi: { text: 'अणु', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c5_8', courseId: 'c5', definition: 'A measure of the concentration of hydrogen ions in a solution, indicating its acidity or alkalinity.',
                    hebrew: { text: 'pH', status: 'Pending', validatedBy: null },
                    pronunciation: 'pi-eytch',
                    english: { text: 'pH', status: 'Pending', validatedBy: null },
                    russian: { text: 'pH', status: 'Pending', validatedBy: null },
                    arabic: { text: 'الأس الهيدروجيني', status: 'Pending', validatedBy: null },
                    french: { text: 'pH', status: 'Pending', validatedBy: null },
                    mandarin: { text: 'pH', status: 'Pending', validatedBy: null },
                    spanish: { text: 'pH', status: 'Pending', validatedBy: null },
                    hindi: { text: 'पीएच', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c5_9', courseId: 'c5', definition: 'A type of chemical bond that involves the sharing of electron pairs between atoms.',
                    hebrew: { text: 'קשר קوולנטי', status: 'Pending', validatedBy: null },
                    pronunciation: 'kesher kovalenti',
                    english: { text: 'Covalent Bond', status: 'Pending', validatedBy: null },
                    russian: { text: 'Ковалентная связь', status: 'Pending', validatedBy: null },
                    arabic: { text: 'رابطة تساهمية', status: 'Pending', validatedBy: null },
                    french: { text: 'Liaison covalente', status: 'Pending', validatedBy: null },
                    mandarin: { text: '共价键', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Enlace covalente', status: 'Pending', validatedBy: null },
                    hindi: { text: 'सहसंयोजक बंधन', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c5_10', courseId: 'c5', definition: 'A type of chemical bond that involves the electrostatic attraction between oppositely charged ions.',
                    hebrew: { text: 'קשר יוני', status: 'Pending', validatedBy: null },
                    pronunciation: 'kesher yoni',
                    english: { text: 'Ionic Bond', status: 'Pending', validatedBy: null },
                    russian: { text: 'Ионная связь', status: 'Pending', validatedBy: null },
                    arabic: { text: 'رابطة أيونية', status: 'Pending', validatedBy: null },
                    french: { text: 'Liaison ionique', status: 'Pending', validatedBy: null },
                    mandarin: { text: '离子键', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Enlace iónico', status: 'Pending', validatedBy: null },
                    hindi: { text: 'आयनिक बंधन', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c5_11', courseId: 'c5', definition: 'A solution that resists changes in pH upon the addition of small amounts of acid or base.',
                    hebrew: { text: 'בופר', status: 'Pending', validatedBy: null },
                    pronunciation: 'buffer',
                    english: { text: 'Buffer (chemistry)', status: 'Pending', validatedBy: null },
                    russian: { text: 'Буфер', status: 'Pending', validatedBy: null },
                    arabic: { text: 'محلول منظم', status: 'Pending', validatedBy: null },
                    french: { text: 'Tampon (chimie)', status: 'Pending', validatedBy: null },
                    mandarin: { text: '缓冲液', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Amortiguador (química)', status: 'Pending', validatedBy: null },
                    hindi: { text: 'बफर', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c5_12', courseId: 'c5', definition: 'A measure of the tendency of an atom to attract a bonding pair of electrons.',
                    hebrew: { text: 'אלקטרושליליות', status: 'Pending', validatedBy: null },
                    pronunciation: 'elektroshliliut',
                    english: { text: 'Electronegativity', status: 'Pending', validatedBy: null },
                    russian: { text: 'Электроотрицательность', status: 'Pending', validatedBy: null },
                    arabic: { text: 'كهروسلبية', status: 'Pending', validatedBy: null },
                    french: { text: 'Électronégativité', status: 'Pending', validatedBy: null },
                    mandarin: { text: '电负性', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Electronegatividad', status: 'Pending', validatedBy: null },
                    hindi: { text: 'विद्युतऋणात्मकता', status: 'Pending', validatedBy: null }
                },

                // Biology 1 Terms (c6)
                {
                    id: 't7', courseId: 'c6', definition: 'The metabolic pathway that converts glucose into pyruvate, which is then used in cellular respiration.',
                    hebrew: { text: 'גליקוליזה', status: 'Pending', validatedBy: null },
                    pronunciation: 'glikoliza',
                    english: { text: 'Glycolysis', status: 'Pending', validatedBy: null },
                    russian: { text: 'Гликолиз', status: 'Pending', validatedBy: null },
                    arabic: { text: 'تحلل الجلوكوز', status: 'Pending', validatedBy: null },
                    french: { text: 'Glycolyse', status: 'Pending', validatedBy: null },
                    mandarin: { text: '糖酵解', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Glucólisis', status: 'Pending', validatedBy: null },
                    hindi: { text: 'ग्लाइकोलाइसिस', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't26', courseId: 'c6', definition: 'Large biological molecules (macromolecules) made of amino acid subunits.',
                    hebrew: { text: 'חלבון', status: 'Pending', validatedBy: null },
                    pronunciation: 'chalbon',
                    english: { text: 'Protein', status: 'Pending', validatedBy: null },
                    russian: { text: 'Белок', status: 'Pending', validatedBy: null },
                    arabic: { text: 'بروتين', status: 'Pending', validatedBy: null },
                    french: { text: 'Protéine', status: 'Pending', validatedBy: null },
                    mandarin: { text: '蛋白质', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Proteína', status: 'Pending', validatedBy: null },
                    hindi: { text: 'प्रोटीन', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c6_3', courseId: 'c6', definition: 'The fundamental structural and functional unit of all known organisms.',
                    hebrew: { text: 'תא', status: 'Pending', validatedBy: null },
                    pronunciation: 'ta',
                    english: { text: 'Cell', status: 'Pending', validatedBy: null },
                    russian: { text: 'Клетка', status: 'Pending', validatedBy: null },
                    arabic: { text: 'خلية', status: 'Pending', validatedBy: null },
                    french: { text: 'Cellule', status: 'Pending', validatedBy: null },
                    mandarin: { text: '细胞', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Célula', status: 'Pending', validatedBy: null },
                    hindi: { text: 'कोशिका', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c6_4', courseId: 'c6', definition: 'The process by which green plants and some other organisms use sunlight to synthesize foods from carbon dioxide and water.',
                    hebrew: { text: 'פוטוסינתזה', status: 'Pending', validatedBy: null },
                    pronunciation: 'fotosinteza',
                    english: { text: 'Photosynthesis', status: 'Pending', validatedBy: null },
                    russian: { text: 'Фотосинтез', status: 'Pending', validatedBy: null },
                    arabic: { text: 'التمثيل الضوئي', status: 'Pending', validatedBy: null },
                    french: { text: 'Photosynthèse', status: 'Pending', validatedBy: null },
                    mandarin: { text: '光合作用', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Fotosíntesis', status: 'Pending', validatedBy: null },
                    hindi: { text: 'प्रकाश संश्लेषण', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c6_5', courseId: 'c6', definition: 'The process in which organisms combine oxygen with foodstuff molecules, diverting the chemical energy in these substances into life-sustaining activities and discarding waste products.',
                    hebrew: { text: 'נשימה תאית', status: 'Pending', validatedBy: null },
                    pronunciation: 'neshima tait',
                    english: { text: 'Cellular Respiration', status: 'Pending', validatedBy: null },
                    russian: { text: 'Клеточное дыхание', status: 'Pending', validatedBy: null },
                    arabic: { text: 'التنفس الخلوي', status: 'Pending', validatedBy: null },
                    french: { text: 'Respiration cellulaire', status: 'Pending', validatedBy: null },
                    mandarin: { text: '细胞呼吸', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Respiración celular', status: 'Pending', validatedBy: null },
                    hindi: { text: 'कोशिकीय श्वसन', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c6_6', courseId: 'c6', definition: 'A molecule carrying the genetic instructions used in the growth, development, functioning, and reproduction of all known organisms and many viruses.',
                    hebrew: { text: 'DNA', status: 'Pending', validatedBy: null },
                    pronunciation: 'di-en-ey',
                    english: { text: 'DNA', status: 'Pending', validatedBy: null },
                    russian: { text: 'ДНК', status: 'Pending', validatedBy: null },
                    arabic: { text: 'الحمض النووي', status: 'Pending', validatedBy: null },
                    french: { text: 'ADN', status: 'Pending', validatedBy: null },
                    mandarin: { text: 'DNA', status: 'Pending', validatedBy: null },
                    spanish: { text: 'ADN', status: 'Pending', validatedBy: null },
                    hindi: { text: 'डीएनए', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c6_7', courseId: 'c6', definition: 'The branch of biology that deals with the relations of organisms to one another and to their physical surroundings.',
                    hebrew: { text: 'אקולוגיה', status: 'Pending', validatedBy: null },
                    pronunciation: 'ekologiya',
                    english: { text: 'Ecology', status: 'Pending', validatedBy: null },
                    russian: { text: 'Экология', status: 'Pending', validatedBy: null },
                    arabic: { text: 'علم البيئة', status: 'Pending', validatedBy: null },
                    french: { text: 'Écologie', status: 'Pending', validatedBy: null },
                    mandarin: { text: '生态学', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Ecología', status: 'Pending', validatedBy: null },
                    hindi: { text: 'पारिस्थितिकी', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c6_8', courseId: 'c6', definition: 'A group of living organisms consisting of similar individuals capable of exchanging genes or interbreeding.',
                    hebrew: { text: 'מין (ביולוגיה)', status: 'Pending', validatedBy: null },
                    pronunciation: 'min (biologia)',
                    english: { text: 'Species', status: 'Pending', validatedBy: null },
                    russian: { text: 'Вид', status: 'Pending', validatedBy: null },
                    arabic: { text: 'نوع (بيولوجيا)', status: 'Pending', validatedBy: null },
                    french: { text: 'Espèce', status: 'Pending', validatedBy: null },
                    mandarin: { text: '物种', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Especie', status: 'Pending', validatedBy: null },
                    hindi: { text: 'प्रजाति', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c6_9', courseId: 'c6', definition: 'The process by which organisms with traits better suited to an environment tend to survive and reproduce more offspring.',
                    hebrew: { text: 'ברירה טבעית', status: 'Pending', validatedBy: null },
                    pronunciation: 'brira tivit',
                    english: { text: 'Natural Selection', status: 'Pending', validatedBy: null },
                    russian: { text: 'Естественный отбор', status: 'Pending', validatedBy: null },
                    arabic: { text: 'الانتخاب الطبيعي', status: 'Pending', validatedBy: null },
                    french: { text: 'Sélection naturelle', status: 'Pending', validatedBy: null },
                    mandarin: { text: '自然选择', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Selección natural', status: 'Pending', validatedBy: null },
                    hindi: { text: 'प्राकृतिक चयन', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c6_10', courseId: 'c6', definition: 'An inherited characteristic that increases an organism\'s chance of survival and reproduction in its environment.',
                    hebrew: { text: 'התאמה', status: 'Pending', validatedBy: null },
                    pronunciation: 'hataama',
                    english: { text: 'Adaptation', status: 'Pending', validatedBy: null },
                    russian: { text: 'Адаптация', status: 'Pending', validatedBy: null },
                    arabic: { text: 'تكيف', status: 'Pending', validatedBy: null },
                    french: { text: 'Adaptation', status: 'Pending', validatedBy: null },
                    mandarin: { text: '适应', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Adaptación', status: 'Pending', validatedBy: null },
                    hindi: { text: 'अनुकूलन', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c6_11', courseId: 'c6', definition: 'The process by which DNA is copied to make a new DNA molecule.',
                    hebrew: { text: 'שכפול DNA', status: 'Pending', validatedBy: null },
                    pronunciation: 'shichpul DNA',
                    english: { text: 'DNA Replication', status: 'Pending', validatedBy: null },
                    russian: { text: 'Репликация ДНК', status: 'Pending', validatedBy: null },
                    arabic: { text: 'تضاعف الحمض النووي', status: 'Pending', validatedBy: null },
                    french: { text: 'Réplication de l\'ADN', status: 'Pending', validatedBy: null },
                    mandarin: { text: 'DNA复制', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Replicación del ADN', status: 'Pending', validatedBy: null },
                    hindi: { text: 'डीएनए प्रतिकृति', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c6_12', courseId: 'c6', definition: 'The genetic makeup of an organism, as opposed to its physical appearance.',
                    hebrew: { text: 'גנוטיפ', status: 'Pending', validatedBy: null },
                    pronunciation: 'genotip',
                    english: { text: 'Genotype', status: 'Pending', validatedBy: null },
                    russian: { text: 'Генотип', status: 'Pending', validatedBy: null },
                    arabic: { text: 'النمط الجيني', status: 'Pending', validatedBy: null },
                    french: { text: 'Génotype', status: 'Pending', validatedBy: null },
                    mandarin: { text: '基因型', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Genotipo', status: 'Pending', validatedBy: null },
                    hindi: { text: 'जीनोटाइप', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c6_13', courseId: 'c6', definition: 'The observable physical or biochemical characteristics of an organism, as determined by both genetic makeup and environmental influences.',
                    hebrew: { text: 'פנוטיפ', status: 'Pending', validatedBy: null },
                    pronunciation: 'fenotip',
                    english: { text: 'Phenotype', status: 'Pending', validatedBy: null },
                    russian: { text: 'Фенотип', status: 'Pending', validatedBy: null },
                    arabic: { text: 'النمط الظاهري', status: 'Pending', validatedBy: null },
                    french: { text: 'Phénotype', status: 'Pending', validatedBy: null },
                    mandarin: { text: '表型', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Fenotipo', status: 'Pending', validatedBy: null },
                    hindi: { text: 'फीनोटाइप', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c6_14', courseId: 'c6', definition: 'The process of producing two identical daughter cells from a single parent cell.',
                    hebrew: { text: 'מיטוזה', status: 'Pending', validatedBy: null },
                    pronunciation: 'mitoza',
                    english: { text: 'Mitosis', status: 'Pending', validatedBy: null },
                    russian: { text: 'Митоз', status: 'Pending', validatedBy: null },
                    arabic: { text: 'انقسام متساو', status: 'Pending', validatedBy: null },
                    french: { text: 'Mitose', status: 'Pending', validatedBy: null },
                    mandarin: { text: '有丝分裂', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Mitosis', status: 'Pending', validatedBy: null },
                    hindi: { text: 'माइटोसिस', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c6_15', courseId: 'c6', definition: 'A type of cell division that reduces the number of chromosomes in the parent cell by half and produces four gamete cells.',
                    hebrew: { text: 'מיוזה', status: 'Pending', validatedBy: null },
                    pronunciation: 'meioza',
                    english: { text: 'Meiosis', status: 'Pending', validatedBy: null },
                    russian: { text: 'Мейоз', status: 'Pending', validatedBy: null },
                    arabic: { text: 'انقسام اختزالي', status: 'Pending', validatedBy: null },
                    french: { text: 'Méiose', status: 'Pending', validatedBy: null },
                    mandarin: { text: '减数分裂', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Meiosis', status: 'Pending', validatedBy: null },
                    hindi: { text: 'अर्धसूत्रीविभाजन', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c6_16', courseId: 'c6', definition: 'An organism that produces its own food, usually by photosynthesis, and forms the base of a food chain.',
                    hebrew: { text: 'יצרן', status: 'Pending', validatedBy: null },
                    pronunciation: 'yatzran',
                    english: { text: 'Producer (biology)', status: 'Pending', validatedBy: null },
                    russian: { text: 'Производитель', status: 'Pending', validatedBy: null },
                    arabic: { text: 'منتج (بيولوجيا)', status: 'Pending', validatedBy: null },
                    french: { text: 'Producteur (biologie)', status: 'Pending', validatedBy: null },
                    mandarin: { text: '生产者', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Productor (biología)', status: 'Pending', validatedBy: null },
                    hindi: { text: 'उत्पादक (जीव विज्ञान)', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c6_17', courseId: 'c6', definition: 'An organism that obtains energy by feeding on other organisms.',
                    hebrew: { text: 'צרכן', status: 'Pending', validatedBy: null },
                    pronunciation: 'tzarchan',
                    english: { text: 'Consumer (biology)', status: 'Pending', validatedBy: null },
                    russian: { text: 'Потребитель', status: 'Pending', validatedBy: null },
                    arabic: { text: 'مستهلك (بيولوجيا)', status: 'Pending', validatedBy: null },
                    french: { text: 'Consommateur (biologie)', status: 'Pending', validatedBy: null },
                    mandarin: { text: '消费者', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Consumidor (biología)', status: 'Pending', validatedBy: null },
                    hindi: { text: 'उपभोक्ता (जीव विज्ञान)', status: 'Pending', validatedBy: null }
                },
                {
                    id: 't_c6_18', courseId: 'c6', definition: 'An organism, especially a soil bacterium, fungus, or invertebrate, that decomposes organic material.',
                    hebrew: { text: 'מפרק', status: 'Pending', validatedBy: null },
                    pronunciation: 'meafreq',
                    english: { text: 'Decomposer', status: 'Pending', validatedBy: null },
                    russian: { text: 'Разлагатель', status: 'Pending', validatedBy: null },
                    arabic: { text: 'محلل', status: 'Pending', validatedBy: null },
                    french: { text: 'Décomposeur', status: 'Pending', validatedBy: null },
                    mandarin: { text: '分解者', status: 'Pending', validatedBy: null },
                    spanish: { text: 'Descomponedor', status: 'Pending', validatedBy: null },
                    hindi: { text: 'अपघटक', status: 'Pending', validatedBy: null }
                }
            ]
        };

        const appData = { courses: [], terms: [] }; // Global appData, initialized empty

        // IMPORTANT: All application logic now resides within this module script.
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('DOM Content Loaded. Starting Firebase initialization...');
            try {
                // Initialize Firebase only once
                if (!firebaseApp) {
                    firebaseApp = initializeApp(firebaseConfig);
                    db = getFirestore(firebaseApp);
                    auth = getAuth(firebaseApp);
                    getAnalytics(firebaseApp); // Initialize Analytics
                    console.log('Firebase services (app, db, auth, analytics) initialized with hardcoded config.');

                    // Update debug info in footer
                    updateDebugInfo();

                    // Set up auth state change listener FIRST. This listener will handle
                    // all subsequent user state changes, including the initial sign-in.
                    onAuthStateChanged(auth, async (user) => {
                        console.log('onAuthStateChanged triggered. User:', user);
                        if (user) {
                            userId = user.uid;
                            console.log('Firebase Auth State Changed: User signed in. User ID:', userId);
                            isFirebaseReady = true; // Set flag to true
                            updateDebugInfo(); // Update debug info with user ID and ready status

                            // After Firebase is ready and user is authenticated, proceed with app initialization
                            console.log('Firebase ready. Calling initializeAppData...');
                            await initializeAppData();
                            // Initial rendering happens here, subsequent updates by onSnapshot listeners
                            renderCourses();
                            populateChallengeGameLanguageSelect();
                            populateLearnHebrewLanguageSelect();
                            showView(homeView);
                        } else {
                            console.log('Firebase Auth State Changed: No user. Attempting anonymous sign-in if not already tried.');
                            // Only try to sign in anonymously if there's no current user (prevents redundant calls)
                            if (!auth.currentUser) {
                                try {
                                    // Use a hardcoded initial auth token if it was meant to be used, otherwise proceed with anonymous.
                                    // As per the instructions, if __initial_auth_token is not defined, we signInAnonymously.
                                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token !== '') {
                                        console.log('Attempting custom token sign-in...');
                                        await signInWithCustomToken(auth, __initial_auth_token);
                                    } else {
                                        console.log('__initial_auth_token not defined. Attempting anonymous sign-in...');
                                        await signInAnonymously(auth);
                                        console.log('Anonymous sign-in attempted.');
                                    }
                                } catch (anonError) {
                                    console.error('Error during initial sign-in (anonymous or custom token):', anonError);
                                    showMessageBox("Error signing in. Functionality may be limited.", "error");
                                    isFirebaseReady = false; // Mark as not ready if auth failed
                                    updateDebugInfo();
                                }
                            }
                        }
                    });

                } else {
                    // If Firebase is already initialized (e.g., due to hot reload in dev env)
                    console.log("Firebase already initialized. Re-initializing app data and rendering.");
                    if (auth && auth.currentUser) {
                        userId = auth.currentUser.uid;
                        isFirebaseReady = true;
                        console.log('Firebase already initialized and user found. User ID:', userId);
                        updateDebugInfo();
                        await initializeAppData();
                        renderCourses();
                        populateChallengeGameLanguageSelect();
                        populateLearnHebrewLanguageSelect();
                        showView(homeView);
                    } else {
                        console.log("Firebase initialized but user not yet available. Waiting for auth state change.");
                        updateDebugInfo();
                        renderCourses(); // Still render to show empty state or old data if any
                        populateChallengeGameLanguageSelect();
                        populateLearnHebrewLanguageSelect();
                        showView(homeView);
                    }
                }
            } catch (error) {
                console.error("Critical error during Firebase initialization or auth setup:", error);
                showMessageBox("Critical error loading application. Please check console for details and try again.", "error");
                renderCourses(); // Attempt to render even on error, might show empty lists
                populateChallengeGameLanguageSelect();
                populateLearnHebrewLanguageSelect();
                showView(homeView);
                updateDebugInfo();
            }
        });

        // Function to update the debug info in the footer
        function updateDebugInfo() {
            const debugInfoElement = document.getElementById('debugInfo');
            if (debugInfoElement) {
                debugInfoElement.innerHTML = `
                    <p>User ID: <span id="displayUserId">${userId || 'N/A (Not authenticated)'}</span></p>
                    <p>Firebase Ready: <span id="displayFirebaseReady">${isFirebaseReady ? 'YES' : 'NO'}</span></p>
                    <p>App ID: <span id="displayAppId">${APP_ID}</span></p>
                `;
            }
        }

        // Function to ensure appData is loaded from Firestore or seeded
        async function initializeAppData() {
            console.log('initializeAppData called.');
            if (!isFirebaseReady || !db || !userId) {
                console.warn("initializeAppData: Firebase is not ready, db is null, or userId is null. Skipping data operations.");
                return;
            }
            console.log(`initializeAppData: Attempting to initialize app data for appId: ${APP_ID}, userId: ${userId}`);

            try {
                // Check if courses collection is empty and seed if necessary
                // Using public/data for courses and terms
                const coursesRef = collection(db, 'artifacts', APP_ID, 'public', 'data', 'courses');
                console.log('initializeAppData: Attempting to get courses snapshot to check for emptiness...');
                const coursesSnapshot = await getDocs(coursesRef);
                console.log('initializeAppData: Courses snapshot received. Is empty:', coursesSnapshot.empty);

                if (coursesSnapshot.empty) {
                    console.log("initializeAppData: Seeding initial data to Firestore...");
                    for (const course of initialAppData.courses) {
                        console.log(`initializeAppData: Seeding course: ${course.name} with ID: ${course.id}`);
                        await setDoc(doc(coursesRef, course.id), course);
                    }
                    const termsCollectionRef = collection(db, 'artifacts', APP_ID, 'public', 'data', 'terms');
                    for (const term of initialAppData.terms) {
                        console.log(`initializeAppData: Seeding term: ${term.hebrew ? term.hebrew.text : term.english.text} with ID: ${term.id}`);
                        await setDoc(doc(termsCollectionRef, term.id), term);
                    }
                    console.log("initializeAppData: Initial data seeding complete.");
                } else {
                    console.log("initializeAppData: Courses collection is not empty. Skipping seeding.");
                }

                // Set up real-time listeners for courses and terms
                console.log('initializeAppData: Setting up real-time listeners for courses and terms...');
                onSnapshot(coursesRef, (snapshot) => {
                    appData.courses = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    console.log("onSnapshot (courses): Data received. Courses count:", appData.courses.length, appData.courses);
                    renderCourses(); // Re-render courses whenever data changes
                    // If a course was being viewed, re-render its terms as well
                    if (currentCourseId) {
                        renderTerms(currentCourseId, courseSearchInput.value.trim());
                    }
                }, (error) => {
                    console.error("onSnapshot (courses): Error fetching courses:", error);
                    showMessageBox("Error loading courses. Please refresh.", "error");
                });

                const termsRef = collection(db, 'artifacts', APP_ID, 'public', 'data', 'terms');
                onSnapshot(termsRef, (snapshot) => {
                    appData.terms = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    console.log("onSnapshot (terms): Data received. Terms count:", appData.terms.length, appData.terms);
                    // Re-render terms for current course if active
                    if (currentCourseId) {
                        renderTerms(currentCourseId, courseSearchInput.value.trim());
                    }
                    // Also update global search results if search view is active
                    if (!searchView.classList.contains('hidden') && globalSearchInput.value.trim().length > 0) {
                        globalSearchInput.onkeyup(); // Trigger search re-render
                    }
                }, (error) => {
                    console.error("onSnapshot (terms): Error fetching terms:", error);
                    showMessageBox("Error loading terms. Please refresh.", "error");
                });
                console.log('initializeAppData: Real-time listeners for courses and terms setup complete.');

            } catch (error) {
                console.error("initializeAppData: Error during initialization (seeding or initial fetch):", error);
                showMessageBox("Error initializing application data. Please check your network connection and Firebase security rules.", "error");
            }
        }

        const VALIDATOR_SECRET_KEY = 'V2025'; // Updated validator key

        let currentCourseId = null; // Tracks the currently viewed course
        let currentTermId = null;   // Tracks the term being edited (null for new term)
        let isValidatorMode = false; // New state variable for validator mode

        // Define the languages for iteration - Hebrew is the primary display language
        const LANGUAGES = [
            { key: 'hebrew', name: 'Hebrew', dir: 'rtl', inputId: 'termHebrew' },
            { key: 'english', name: 'English', dir: 'ltr', inputId: 'termEnglish' },
            { key: 'russian', name: 'Russian', dir: 'ltr', inputId: 'termRussian' },
            { key: 'arabic', name: 'Arabic', dir: 'rtl', inputId: 'termArabic' },
            { key: 'french', name: 'French', dir: 'ltr', inputId: 'termFrench' },
            { key: 'mandarin', name: 'Mandarin', dir: 'ltr', inputId: 'termMandarin' },
            { key: 'spanish', name: 'Spanish', dir: 'ltr', inputId: 'termSpanish' },
            { key: 'hindi', name: 'Hindi', dir: 'ltr', inputId: 'termHindi' }
        ];

        // --- UI Elements ---
        const homeView = document.getElementById('homeView');
        const searchView = document.getElementById('searchView'); // New search view
        const addCourseView = document.getElementById('addCourseView');
        const courseDetailsView = document.getElementById('courseDetailsView');
        const addTermView = document.getElementById('addTermView');
        const challengeGameView = document.getElementById('challengeGameView'); // Renamed game view
        const learnHebrewView = document.getElementById('learnHebrewView'); // New learn Hebrew view
        const messageBoxContainer = document.getElementById('messageBoxContainer');

        const homeButton = document.getElementById('homeButton');
        const validatorAuthButton = document.getElementById('validatorAuthButton');
		const becomeValidator = document.getElementById('becomeValidator');
        const challengeGameButton = document.getElementById('challengeGameButton'); // Renamed button
        const searchButton = document.getElementById('searchButton'); // New search button
        const learnHebrewButton = document.getElementById('learnHebrewButton'); // New learn Hebrew button
        const showAddCourseFormBtn = document.getElementById('showAddCourseFormBtn');
        const addCourseForm = document.getElementById('addCourseForm');
        const cancelAddCourseBtn = document.getElementById('cancelAddCourseBtn');
        const courseList = document.getElementById('courseList');
        const courseDetailsTitle = document.getElementById('courseDetailsTitle');
        const showAddTermFormBtn = document.getElementById('showAddTermFormBtn'); // Corrected typo here
        const addTermForm = document.getElementById('addTermForm');
        const addTermFormTitle = document.getElementById('addTermFormTitle');
        const addTermSubmitBtn = document.getElementById('addTermSubmitBtn');
        const cancelAddTermBtn = document.getElementById('cancelAddTermBtn');
        const termList = document.getElementById('termList');
        const noTermsMessage = document.getElementById('noTermsMessage');
        const globalSearchInput = document.getElementById('globalSearchInput');
        const searchResultsList = document.getElementById('searchResultsList');
        const noSearchResultsMessage = document.getElementById('noSearchResultsMessage'); // New message for search
        const clearSearchBtn = document.getElementById('clearSearchBtn');
        const courseSearchInput = document.getElementById('courseSearchInput'); // Element for course-specific search

        // New pronunciation input element
        const termPronunciationInput = document.getElementById('termPronunciation');

        // New: Download CSV Button (Request 3)
        const downloadTermsCsvBtn = document.getElementById('downloadTermsCsvBtn');


        // Linguini Challenge Game UI Elements
        const challengeGameStartScreen = document.getElementById('challengeGameStartScreen');
        const challengeGameLanguageSelect = document.getElementById('challengeGameLanguageSelect');
        const startChallengeGameButton = document.getElementById('startChallengeGameButton');
        const challengeGamePlayScreen = document.getElementById('challengeGamePlayScreen');
        const challengeGameScoreDisplay = document.getElementById('challengeGameScore');
        const challengeGameTimerDisplay = document.getElementById('challengeGameTimer');
        const challengeGameTermDisplay = document.getElementById('challengeGameTermDisplay');
        const challengeOption1Button = document.getElementById('challengeOption1');
        const challengeOption2Button = document.getElementById('challengeOption2');
        const challengeGameFeedbackDisplay = document.getElementById('challengeGameFeedback');
        const challengeGameOverScreen = document.getElementById('challengeGameOverScreen');
        const challengeFinalScoreDisplay = document.getElementById('challengeFinalScore');
        const playAgainChallengeButton = document.getElementById('playAgainChallengeButton');

        // Linguini Challenge Game State Variables
        let challengeGameScore = 0;
        let challengeGameTimeLeft = 30;
        let challengeGameTimerInterval;
        let challengeGameCurrentTerm = null;
        let challengeGameCorrectOptionKey = null;
        let challengeGameSelectedLanguage = null;

        // Learn Hebrew Game UI Elements
        const learnHebrewStartScreen = document.getElementById('learnHebrewStartScreen');
        const learnHebrewLanguageSelect = document.getElementById('learnHebrewLanguageSelect');
        const startLearningButton = document.getElementById('startLearningButton');
        const learnHebrewPlayScreen = document.getElementById('learnHebrewPlayScreen');
        const hebrewTermDisplay = document.getElementById('hebrewTermDisplay');
        const pronunciationDisplay = document.getElementById('pronunciationDisplay'); // New pronunciation display
        const learnHebrewOption1Button = document.getElementById('learnHebrewOption1'); // New option buttons
        const learnHebrewOption2Button = document.getElementById('learnHebrewOption2');
        const learnHebrewFeedbackDisplay = document.getElementById('learnHebrewFeedback'); // New feedback display
        const learnHebrewNextWordButton = document.getElementById('learnHebrewNextWordButton'); // New next word button
        const masteredWordsCountDisplay = document.getElementById('masteredWordsCount');
        const learningProgressDisplay = document.getElementById('learningProgress');
        const learnHebrewEndScreen = document.getElementById('learnHebrewEndScreen');
        const finalMasteredCountDisplay = document.getElementById('finalMasteredCount');
        const startNewLearningSessionButton = document.getElementById('startNewLearningSessionButton');

        // Learn Hebrew Game State Variables
        let learnHebrewSelectedLanguage = null;
        let learningTerms = []; // Terms for the current learning session
        let currentLearningIndex = 0;
        let masteredWordsCount = 0;

        // Tone.js Synths for sound effects
        const correctSynth = new Tone.Synth().toDestination();
        const incorrectSynth = new Tone.MembraneSynth().toDestination();
        const gameOverSynth = new Tone.MembraneSynth().toDestination();
        const flipSynth = new Tone.PolySynth().toDestination();

        // --- Learn Hebrew Game Vocabulary (Pre-filled, fixed database) ---
        // This uses the same term structure, but is a fixed set for the Learn Hebrew game.
        const learnHebrewVocabulary = [
            {
                hebrew: 'גם',
                pronunciation: 'gam',
                english: 'also',
                russian: 'тоже',
                arabic: 'أيضا',
                french: 'aussi',
                mandarin: '也',
                spanish: 'también',
                hindi: 'भी'
            },
            {
                hebrew: 'אולי',
                pronunciation: 'ulay',
                english: 'maybe',
                russian: 'может быть',
                arabic: 'ربما',
                french: 'peut-être',
                mandarin: '可能',
                spanish: 'quizás',
                hindi: 'शायद'
            },
            {
                hebrew: 'ייתכן',
                pronunciation: 'yitachen',
                english: 'possible',
                russian: 'возможно',
                arabic: 'ممكن',
                french: 'possible',
                mandarin: '可能',
                spanish: 'posible',
                hindi: 'संभव'
            },
            {
                hebrew: 'להוכיח',
                pronunciation: 'lehochiach',
                english: 'to prove',
                russian: 'доказать',
                arabic: 'لإثبات',
                french: 'prouver',
                mandarin: '证明',
                spanish: 'probar',
                hindi: 'सिद्ध करना'
            },
            {
                hebrew: 'מצא',
                pronunciation: 'matza',
                english: 'found (he/it)',
                russian: 'нашел',
                arabic: 'وجد',
                french: 'trouvé',
                mandarin: '找到',
                spanish: 'encontró',
                hindi: 'पाया'
            },
            {
                hebrew: 'כאשר',
                pronunciation: 'kaasher',
                english: 'when (as)',
                russian: 'когда',
                arabic: 'عندما',
                french: 'lorsque',
                mandarin: '当...时',
                spanish: 'cuando',
                hindi: 'जब'
            },
            {
                hebrew: 'לכן',
                pronunciation: 'lakhen',
                english: 'therefore',
                russian: 'поэтому',
                arabic: 'لذلك',
                french: 'donc',
                mandarin: '因此',
                spanish: 'por lo tanto',
                hindi: 'इसलिए'
            },
            {
                hebrew: 'בנוסף',
                pronunciation: 'benosaf',
                english: 'in addition',
                russian: 'кроме того',
                arabic: 'بالإضافة إلى ذلك',
                french: 'en plus',
                mandarin: '此外',
                spanish: 'además',
                hindi: 'इसके अतिरिक्त'
            },
            {
                hebrew: 'בדרך כלל',
                pronunciation: 'bederech klal',
                english: 'usually',
                russian: 'обычно',
                arabic: 'عادة',
                french: 'habituellement',
                mandarin: '通常',
                spanish: 'normalmente',
                hindi: 'आमतौर पर'
            },
            {
                hebrew: 'חשוב',
                pronunciation: 'hashuv',
                english: 'important',
                russian: 'важный',
                arabic: 'مهم',
                french: 'important',
                mandarin: '重要的',
                spanish: 'importante',
                hindi: 'महत्वपूर्ण'
            },
            {
                hebrew: 'פתרון',
                pronunciation: 'pitaron',
                english: 'solution',
                russian: 'решение',
                arabic: 'حل',
                french: 'solution',
                mandarin: '解决方案',
                spanish: 'solución',
                hindi: 'समाधान'
            },
            {
                hebrew: 'קבוע',
                pronunciation: 'kavua',
                english: 'constant',
                russian: 'постоянный',
                arabic: 'ثابت',
                french: 'constant',
                mandarin: '常数',
                spanish: 'constante',
                hindi: 'स्थिर'
            },
            {
                hebrew: 'פונקציה',
                pronunciation: 'funktsia',
                english: 'function',
                russian: 'функция',
                arabic: 'دالة',
                french: 'fonction',
                mandarin: '函数',
                spanish: 'función',
                hindi: 'फ़ंक्शन'
            },
            {
                hebrew: 'משוואה',
                pronunciation: 'mishvaah',
                english: 'equation',
                russian: 'уравнение',
                arabic: 'معادلة',
                french: 'équation',
                mandarin: '方程',
                spanish: 'ecuación',
                hindi: 'समीकरण'
            },
            {
                hebrew: 'מערכת',
                pronunciation: 'maarechet',
                english: 'system',
                russian: 'система',
                arabic: 'نظام',
                french: 'système',
                mandarin: '系统',
                spanish: 'sistema',
                hindi: 'प्रणाली'
            }
        ];


        // --- Utility Functions (Already present in your working code) ---

        // Function to show a custom message box
        function showMessageBox(message, type = 'info', callback = null) {
            console.log(`Displaying message box: Type=${type}, Message=${message}`);
            const backdrop = document.createElement('div');
            backdrop.className = 'message-box-backdrop';
            backdrop.id = 'messageBackdrop';

            const box = document.createElement('div');
            box.className = 'message-box';
            box.innerHTML = `
                <p class="text-lg font-medium mb-4">${message}</p>
                <button id="messageBoxOkBtn" class="px-6 py-2 rounded-md bg-emerald-500 text-white hover:bg-emerald-600 transition">OK</button>
            `;

            messageBoxContainer.appendChild(backdrop);
            messageBoxContainer.appendChild(box);

            document.getElementById('messageBoxOkBtn').onclick = () => {
                console.log('Message box OK clicked.');
                messageBoxContainer.innerHTML = ''; // Clear message box
                if (callback) callback();
            };
        }

        // Function to show a custom confirmation box
        function showConfirmBox(message, onConfirm, onCancel) {
            console.log(`Displaying confirm box: Message=${message}`);
            const backdrop = document.createElement('div');
            backdrop.className = 'message-box-backdrop';
            backdrop.id = 'confirmBackdrop';

            const box = document.createElement('div');
            box.className = 'message-box';
            box.innerHTML = `
                <p class="text-lg font-medium mb-4">${message}</p>
                <div class="flex justify-center gap-4">
                    <button id="confirmBoxYesBtn" class="px-6 py-2 rounded-md bg-emerald-500 text-white hover:bg-emerald-600 transition">Yes</button>
                    <button id="confirmBoxNoBtn" class="px-6 py-2 rounded-md bg-red-500 text-white hover:bg-red-600 transition">No</button>
                </div>
            `;

            messageBoxContainer.appendChild(backdrop);
            messageBoxContainer.appendChild(box);

            document.getElementById('confirmBoxYesBtn').onclick = () => {
                console.log('Confirm box YES clicked.');
                messageBoxContainer.innerHTML = '';
                onConfirm();
            };
            document.getElementById('confirmBoxNoBtn').onclick = () => {
                console.log('Confirm box NO clicked.');
                messageBoxContainer.innerHTML = '';
                if (onCancel) onCancel();
            };
        }

        // Function to show a custom prompt box
        function showPromptBox(message, onConfirm) {
            console.log(`Displaying prompt box: Message=${message}`);
            const backdrop = document.createElement('div');
            backdrop.className = 'message-box-backdrop';
            backdrop.id = 'promptBackdrop';

            const box = document.createElement('div');
            box.className = 'message-box';
            box.innerHTML = `
                <p class="text-lg font-medium mb-4">${message}</p>
                <input type="password" id="promptInput" class="mb-4" placeholder="Enter secret key">
                <div class="flex justify-center gap-4">
                    <button id="promptBoxOkBtn" class="px-6 py-2 rounded-md bg-emerald-500 text-white hover:bg-emerald-600 transition">OK</button>
                    <button id="promptBoxCancelBtn" class="px-6 py-2 rounded-md bg-gray-500 text-white hover:bg-gray-600 transition">Cancel</button>
                </div>
            `;

            messageBoxContainer.appendChild(backdrop);
            messageBoxContainer.appendChild(box);

            document.getElementById('promptBoxOkBtn').onclick = () => {
                const inputValue = document.getElementById('promptInput').value;
                console.log('Prompt box OK clicked. Input:', inputValue);
                messageBoxContainer.innerHTML = '';
                onConfirm(inputValue);
            };
            document.getElementById('promptBoxCancelBtn').onclick = () => {
                console.log('Prompt box CANCEL clicked.');
                messageBoxContainer.innerHTML = '';
            };
        }


        // Function to switch views
        function showView(viewElement) {
            console.log('Switching view to:', viewElement.id);
            document.querySelectorAll('.view').forEach(view => view.classList.add('hidden'));
            viewElement.classList.remove('hidden');
        }

        // Generate a simple unique ID (not used for Firestore `addDoc` but kept if needed elsewhere)
        function generateId() {
            return '_' + Math.random().toString(36).substr(2, 9);
        }

        // Determines the overall status of a term based on its language statuses
        function getOverallTermStatus(term) {
            let providedLanguages = 0;
            let validatedLanguages = 0;

            LANGUAGES.forEach(lang => {
                if (term[lang.key] && term[lang.key].text) {
                    providedLanguages++;
                    if (term[lang.key].status === 'Validated') {
                        validatedLanguages++;
                    }
                }
            });

            if (providedLanguages === 0) {
                return 'No Content'; // Should not happen if Hebrew is required
            } else if (validatedLanguages === providedLanguages) {
                return 'Fully Validated';
            } else if (validatedLanguages > 0) {
                return 'Partially Validated';
            } else {
                return 'Pending';
            }
        }

        // Get a random element from an array
        function getRandomElement(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        // Shuffle an array (Fisher-Yates algorithm)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // --- Render Functions ---

        // Renders the list of courses
        function renderCourses() {
            console.log('renderCourses: Started rendering courses. Current appData.courses:', appData.courses);
            courseList.innerHTML = '';
            if (appData.courses.length === 0) {
                courseList.innerHTML = '<p class="text-gray-500 text-center col-span-full">No courses added yet. Be the first!</p>';
                console.log('renderCourses: No courses to display.');
                return;
            }
            appData.courses.forEach(course => {
                const courseCard = document.createElement('div');
                courseCard.className = 'card cursor-pointer hover:bg-blue-50 transition flex justify-between items-center';
                courseCard.innerHTML = `
                    <h3 class="text-xl font-semibold">${course.name}</h3>
                    <div class="flex gap-2">
                        ${isValidatorMode ? `<button class="btn-delete px-3 py-1 text-sm" data-course-id="${course.id}">Delete</button>` : ''}
                    </div>
                `;
                // Add event listener for course name to view details
                courseCard.querySelector('h3').onclick = () => {
                    console.log(`renderCourses: Clicking course H3 for ID: ${course.id}`);
                    viewCourseDetails(course.id);
                };
                
                // Only attach delete event listener if the button exists and in validator mode
                const deleteBtn = courseCard.querySelector('.btn-delete');
                if (isValidatorMode && deleteBtn) {
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation(); // Prevent card click from triggering viewCourseDetails
                        console.log(`renderCourses: Clicking delete button for course ID: ${course.id}`);
                        deleteCourse(course.id);
                    };
                }
                courseList.appendChild(courseCard);
            });
            console.log('renderCourses: Finished rendering courses.');
        }

        // Renders the list of terms for a specific course (Modified for mobile table display - Request 2)
        function renderTerms(courseId, searchTerm = '') {
            console.log('renderTerms: Started rendering terms for course:', courseId, 'Search term:', searchTerm);
            termList.innerHTML = '';
            const termsForCourse = appData.terms.filter(term => term.courseId === courseId);
            const filteredTerms = searchTerm
                ? termsForCourse.filter(term =>
                    // Search across all language texts and definition
                    LANGUAGES.some(lang =>
                        term[lang.key] && term[lang.key].text && term[lang.key].text.toLowerCase().includes(searchTerm.toLowerCase())
                    ) || (term.definition && term.definition.toLowerCase().includes(searchTerm.toLowerCase())) ||
                    (term.pronunciation && term.pronunciation.toLowerCase().includes(searchTerm.toLowerCase())) // Include pronunciation in search
                )
                : termsForCourse;

            if (filteredTerms.length === 0) {
                noTermsMessage.classList.remove('hidden');
                console.log('renderTerms: No terms found for current course (or after filtering).');
                return;
            } else {
                noTermsMessage.classList.add('hidden');
            }

            filteredTerms.forEach(term => {
                const termOverallStatus = getOverallTermStatus(term);
                let overallStatusClass = '';
                if (termOverallStatus === 'Fully Validated') {
                    overallStatusClass = 'status-overall-fully-validated';
                } else if (termOverallStatus === 'Partially Validated') {
                    overallStatusClass = 'status-overall-partially-validated';
                } else {
                    overallStatusClass = 'status-overall-pending';
                }

                // Display the Hebrew term as the main heading
                const mainHebrewTerm = term.hebrew && term.hebrew.text ? term.hebrew.text : '';
                const mainEnglishPronunciation = term.pronunciation || ''; // Use the stored pronunciation
                const mainDefinition = term.definition;

                const termCard = document.createElement('div');
                termCard.className = 'card';
                // IMPORTANT: All buttons now include data-term-id for event delegation.
                termCard.innerHTML = `
                    <h3 class="text-xl font-semibold mb-2" dir="rtl">${mainHebrewTerm}</h3>
                    <p class="text-gray-600 mb-2">${mainEnglishPronunciation ? `(${mainEnglishPronunciation})` : ''}</p>
                    <p class="text-gray-700 mb-4">${mainDefinition}</p>

                    <div class="flex flex-wrap justify-between items-center mt-4 gap-2">
                        <button class="btn-secondary toggle-translations-btn px-4 py-2 text-sm" data-term-id="${term.id}">View Translations</button>
                        <span class="text-sm ${overallStatusClass}">
                            Overall Status: ${termOverallStatus}
                        </span>
                        <div class="flex gap-2">
                            <button class="btn-edit px-3 py-1 text-sm" data-term-id="${term.id}">Edit</button>
                            <button class="btn-delete px-3 py-1 text-sm" data-term-id="${term.id}">Delete Term</button>
                        </div>
                    </div>

                    <div id="termTranslations_${term.id}" class="hidden">
                        <table class="term-table mt-4">
                            <thead>
                                <tr>
                                    <th>Language</th>
                                    <th>Translation</th>
                                    <th>Status</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td data-label="Language">Pronunciation</td>
                                    <td data-label="Translation">${mainEnglishPronunciation || 'N/A'}</td>
                                    <td data-label="Status" class="status-not-provided">N/A</td>
                                    <td data-label="Actions"></td>
                                </tr>
                                ${LANGUAGES.map(lang => {
                                    if (lang.key === 'hebrew') return ''; // Hebrew term is already displayed
                                    const termLang = term[lang.key];
                                    const hasText = termLang && termLang.text;
                                    const status = hasText ? termLang.status : 'Not Provided';
                                    const statusClass = hasText
                                        ? (status === 'Validated' ? 'status-validated' : 'status-pending')
                                        : 'status-not-provided';
                                    const translationText = hasText ? termLang.text : 'N/A';
                                    const dirAttribute = lang.dir === 'rtl' ? 'dir="rtl"' : '';

                                    return `
                                        <tr>
                                            <td data-label="Language">${lang.name}</td>
                                            <td data-label="Translation" ${dirAttribute}>${translationText}</td>
                                            <td data-label="Status" class="${statusClass}">${status}</td>
                                            <td data-label="Actions">
                                                ${isValidatorMode && hasText && status === 'Pending' ?
                                                    `<button class="btn-validate px-3 py-1 text-xs" data-term-id="${term.id}" data-lang-key="${lang.key}">Validate</button>` : ''}
                                            </td>
                                        </tr>
                                    `;
                                }).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
                termList.appendChild(termCard);

                // Add event listener for the "View Translations" button
                const toggleBtn = termCard.querySelector(`.toggle-translations-btn`);
                toggleBtn.onclick = () => {
                    console.log(`renderTerms: Toggling translations for term ID: ${term.id}`);
                    const translationsDiv = document.getElementById(`termTranslations_${term.id}`);
                    translationsDiv.classList.toggle('hidden');
                    // Change button text
                    if (translationsDiv.classList.contains('hidden')) {
                        toggleBtn.textContent = 'View Translations';
                    } else {
                        toggleBtn.textContent = 'Hide Translations';
                    }
                };
            });
            console.log('renderTerms: Finished rendering terms.');
        }

        // Renders search results
        function renderSearchResults(results) {
            console.log('renderSearchResults: Started rendering search results. Results count:', results.length);
            searchResultsList.innerHTML = '';
            if (results.length === 0) {
                noSearchResultsMessage.classList.remove('hidden');
                console.log('renderSearchResults: No search results to display.');
                return;
            } else {
                noSearchResultsMessage.classList.add('hidden');
            }
            results.forEach(term => {
                const termOverallStatus = getOverallTermStatus(term);
                let overallStatusClass = '';
                if (termOverallStatus === 'Fully Validated') {
                    overallStatusClass = 'status-overall-fully-validated';
                } else if (termOverallStatus === 'Partially Validated') {
                    overallStatusClass = 'status-overall-partially-validated';
                } else {
                    overallStatusClass = 'status-overall-pending';
                }

                // Display the Hebrew term as the main heading in search results
                const mainTermDisplay = term.hebrew && term.hebrew.text ? term.hebrew.text : (term.english && term.english.text ? term.english.text : 'Untitled Term');

                const termCard = document.createElement('div');
                termCard.className = 'card';
                termCard.innerHTML = `
                    <h3 class="text-lg font-semibold mb-1" dir="rtl">${mainTermDisplay}</h3>
                    <p class="text-gray-700 text-sm mb-2">${term.definition.substring(0, 100)}${term.definition.length > 100 ? '...' : ''}</p>
                    <p class="text-xs text-gray-500">Course: ${appData.courses.find(c => c.id === term.courseId)?.name || 'Unknown'}</p>
                    <span class="text-xs ${overallStatusClass}">
                        Overall Status: ${termOverallStatus}
                    </span>
                `;
                searchResultsList.appendChild(termCard);
            });
            console.log('renderSearchResults: Finished rendering search results.');
        }

        // --- Event Handlers ---

        // Handle validator login/logout
        validatorAuthButton.onclick = () => {
            console.log('validatorAuthButton clicked. isValidatorMode:', isValidatorMode);
            if (!isFirebaseReady) {
                showMessageBox("Firebase is not ready. Please wait a moment.", "error");
                return;
            }
            if (isValidatorMode) {
                // Logout
                isValidatorMode = false;
                validatorAuthButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                                    <path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/>
                                                    <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
                                                </svg>Validator Login`;
                showMessageBox('Logged out of Validator Mode.', 'info', renderCourses); // Re-render to hide buttons
            } else {
                // Login
                showPromptBox('Enter validator secret key:', (key) => {
                    if (key === VALIDATOR_SECRET_KEY) {
                        isValidatorMode = true;
                        validatorAuthButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                                            <path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/>
                                                            <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
                                                        </svg>Validator Logout`;
                        showMessageBox('Successfully logged into Validator Mode!', 'success', renderCourses); // Re-render to show buttons
                    } else {
                        showMessageBox('Invalid secret key. Access denied.', 'error');
                    }
                });
            }
        };

        // NEW JAVASCRIPT: Handle "Become a Validator" button click

becomeValidator.onclick = async () => {
    console.log('BecomeValidator button clicked.');
    const languageToValidate = prompt("Which language do you want to validate? (e.g., English, Russian, Arabic, Spanish, Mandarin, French, Hindi)");
    if (!languageToValidate) {
        showMessageBox("Validator request cancelled. Please specify a language.", 'error');
        return;
    }
    let proficiencyLevel = prompt(`On a scale of 1 to 5, how would you rank your control in ${languageToValidate}? (1=Beginner, 5=Native/Expert)`);
    proficiencyLevel = parseInt(proficiencyLevel, 10);
    if (isNaN(proficiencyLevel) || proficiencyLevel < 1 || proficiencyLevel > 5) {
        showMessageBox("Invalid proficiency level. Please enter a number between 1 and 5.", 'error');
        return;
    }
    if (proficiencyLevel < 4) {
        showMessageBox(`Your proficiency level (${proficiencyLevel}) in ${languageToValidate} is too low to become a validator. A level of 4 or higher is required.`, 'error');
        return;
    }
    const agreementText = `By becoming a validator for ${languageToValidate} (Proficiency: ${proficiencyLevel}), you agree to provide accurate and truthful translations. Your contributions help maintain the integrity of our educational platform. Do you accept this responsibility?`;
    
    showConfirmBox(agreementText, async () => {
        // User accepted
        const VALIDATOR_SECRET_KEY = "V2025";
        // Directly show the secret key after successful update
        showMessageBox(`Thank you for your commitment! You are now a validator for ${languageToValidate}. The validator secret key is: ${VALIDATOR_SECRET_KEY}`, 'info');
    });
};


        // Handle adding a new course
        addCourseForm.onsubmit = async (e) => {
            e.preventDefault();
            console.log('addCourseForm submitted.');
            if (!isFirebaseReady || !db || !userId) {
                console.error("addCourseForm: Firebase not ready or user not authenticated. isFirebaseReady:", isFirebaseReady, "db:", db, "userId:", userId);
                showMessageBox("Firebase is not ready or user not authenticated. Please wait a moment.", "error");
                return;
            }
            const courseName = document.getElementById('courseName').value.trim();
            if (courseName) {
                const newCourse = {
                    name: courseName
                    // Firestore will generate the ID for addDoc
                };
                console.log('addCourseForm: Attempting to add course with data:', newCourse);
                try {
                    // Using addDoc to let Firestore generate a unique ID
                    const docRef = await addDoc(collection(db, 'artifacts', APP_ID, 'public', 'data', 'courses'), newCourse);
                    console.log('addCourseForm: Course added successfully. Document ID:', docRef.id);
                    showMessageBox('Course added successfully!', 'success', () => {
                        addCourseForm.reset();
                        showView(homeView);
                        // renderCourses is called by the onSnapshot listener
                    });
                } catch (error) {
                    console.error("addCourseForm: Error adding course: ", error);
                    showMessageBox('Error adding course. Please try again.', 'error');
                }
            } else {
                console.warn('addCourseForm: Course name is empty.');
                showMessageBox('Course name cannot be empty.', 'error');
            }
        };

        // Handle adding or editing a term
        addTermForm.onsubmit = async (e) => {
            e.preventDefault();
            console.log('addTermForm submitted. currentTermId:', currentTermId);
            if (!isFirebaseReady || !db || !userId) {
                console.error("addTermForm: Firebase not ready or user not authenticated. isFirebaseReady:", isFirebaseReady, "db:", db, "userId:", userId);
                showMessageBox("Firebase is not ready or user not authenticated. Please wait a moment.", "error");
                return;
            }
            const termHebrew = document.getElementById('termHebrew').value.trim();
            const termDefinition = document.getElementById('termDefinition').value.trim();
            const termPronunciation = termPronunciationInput.value.trim(); // Get value from the new input

            if (!termHebrew || !termDefinition || !currentCourseId) {
                console.warn('addTermForm: Hebrew term, definition, or course ID is missing.');
                showMessageBox('Hebrew term and definition are required.', 'error');
                return;
            }

            let termData = {
                definition: termDefinition,
                pronunciation: termPronunciation, // Use the value from the new input
            };

            // Process all language fields, ensuring status is handled correctly for updates
            const currentTermInAppData = appData.terms.find(t => t.id === currentTermId);
            LANGUAGES.forEach(lang => {
                const inputElement = document.getElementById(lang.inputId);
                const newText = inputElement ? inputElement.value.trim() : '';

                if (newText) {
                    const existingLangData = currentTermInAppData ? currentTermInAppData[lang.key] : null;
                    if (existingLangData && existingLangData.text === newText && existingLangData.status === 'Validated') {
                        // If text hasn't changed and was already validated, preserve status and validatedBy
                        termData[lang.key] = {
                            text: newText,
                            status: 'Validated',
                            validatedBy: existingLangData.validatedBy
                        };
                        console.log(`addTermForm: Preserving validated status for ${lang.key}:`, termData[lang.key]);
                    } else {
                        // If text changed or was never validated, set to Pending
                        termData[lang.key] = {
                            text: newText,
                            status: 'Pending',
                            validatedBy: null
                        };
                        console.log(`addTermForm: Setting pending status for ${lang.key}:`, termData[lang.key]);
                    }
                } else {
                    termData[lang.key] = null; // Clear if input is empty
                    console.log(`addTermForm: Clearing ${lang.key} data.`);
                }
            });

            console.log('addTermForm: Final term data to save:', termData);

            try {
                if (currentTermId) { // Editing an existing term
                    console.log('addTermForm: Attempting to update existing term with ID:', currentTermId);
                    const termRef = doc(db, 'artifacts', APP_ID, 'public', 'data', 'terms', currentTermId);
                    await updateDoc(termRef, termData); // Use updateDoc for partial update
                    console.log('addTermForm: Term updated successfully!');
                    showMessageBox('Term updated successfully!', 'success', () => {
                        addTermForm.reset();
                        currentTermId = null; // Clear editing state
                        viewCourseDetails(currentCourseId); // Go back to course details
                    });
                } else { // Adding a new term
                    termData.courseId = currentCourseId;
                    console.log('addTermForm: Attempting to add new term:', termData);
                    const docRef = await addDoc(collection(db, 'artifacts', APP_ID, 'public', 'data', 'terms'), termData); // Use addDoc
                    console.log('addTermForm: New term added successfully. Document ID:', docRef.id);
                    showMessageBox('Term added successfully! Individual translations are pending validation.', 'success', () => {
                        addTermForm.reset();
                        currentTermId = null; // Clear editing state
                        viewCourseDetails(currentCourseId); // Go back to course details
                    });
                }
            } catch (error) {
                console.error("addTermForm: Error adding/updating term: ", error);
                showMessageBox('Error saving term. Please try again.', 'error');
            }
        };

        // Function to prepare the form for editing a term
        async function editTerm(termId) {
            console.log('editTerm: Called for term ID:', termId);
            if (!isFirebaseReady || !db || !userId) {
                console.error("editTerm: Firebase not ready or user not authenticated. isFirebaseReady:", isFirebaseReady, "db:", db, "userId:", userId);
                showMessageBox("Firebase is not ready or user not authenticated. Please wait a moment.", "error");
                return;
            }
            currentTermId = termId;
            const termRef = doc(db, 'artifacts', APP_ID, 'public', 'data', 'terms', termId);
            try {
                console.log('editTerm: Fetching term document from Firestore...');
                const termDoc = await getDoc(termRef);
                if (termDoc.exists()) {
                    const term = termDoc.data();
                    console.log('editTerm: Term data fetched:', term);
                    addTermFormTitle.textContent = 'Edit Term';
                    addTermSubmitBtn.textContent = 'Save Changes';

                    document.getElementById('termDefinition').value = term.definition;
                    termPronunciationInput.value = term.pronunciation || ''; // Pre-fill pronunciation

                    LANGUAGES.forEach(lang => {
                        const inputElement = document.getElementById(lang.inputId);
                        if (inputElement) {
                            inputElement.value = term[lang.key] && term[lang.key].text ? term[lang.key].text : '';
                        }
                    });

                    showView(addTermView);
                } else {
                    console.warn('editTerm: Term not found in Firestore for ID:', termId);
                    showMessageBox('Term not found for editing.', 'error');
                    currentTermId = null; // Reset if term not found
                }
            } catch (error) {
                console.error("editTerm: Error fetching term for edit: ", error);
                showMessageBox('Error fetching term data. Please try again.', 'error');
            }
        }


        // Validate a term for a specific language using the secret key
        function validateTerm(termId, langKey) {
            console.log(`validateTerm: Called for term ID: ${termId}, language: ${langKey}`);
            if (!isFirebaseReady || !db || !userId) {
                console.error("validateTerm: Firebase not ready or user not authenticated. isFirebaseReady:", isFirebaseReady, "db:", db, "userId:", userId);
                showMessageBox("Firebase is not ready or user not authenticated. Please wait a moment.", "error");
                return;
            }
            showPromptBox(`Enter validator secret key for ${langKey} translation:`, async (key) => {
                if (key === VALIDATOR_SECRET_KEY) {
                    const termRef = doc(db, 'artifacts', APP_ID, 'public', 'data', 'terms', termId);
                    try {
                        console.log(`validateTerm: Fetching term document to validate ${langKey}...`);
                        const termDoc = await getDoc(termRef);
                        if (termDoc.exists() && termDoc.data()[langKey]) {
                            const updatePath = `${langKey}.status`;
                            const validatedByPath = `${langKey}.validatedBy`;
                            console.log(`validateTerm: Updating term ID ${termId}, field ${updatePath} to 'Validated' by ${userId}`);
                            await updateDoc(termRef, {
                                [updatePath]: 'Validated',
                                [validatedByPath]: userId // Use actual user ID
                            });
                            console.log(`validateTerm: ${langKey} translation validated successfully!`);
                            showMessageBox(`${langKey} translation validated successfully!`, 'success', () => {
                                // renderTerms is called by the onSnapshot listener, which will update the UI
                            });
                        } else {
                            console.warn(`validateTerm: Could not validate ${langKey} translation for term ID ${termId}. Term or language data not found/already validated.`);
                            showMessageBox(`Could not validate ${langKey} translation. It might not exist or already be validated.`, 'error');
                        }
                    } catch (error) {
                        console.error("validateTerm: Error validating term: ", error);
                        showMessageBox('Error validating translation. Please try again.', 'error');
                    }
                } else {
                    console.warn('validateTerm: Invalid secret key provided.');
                    showMessageBox('Invalid secret key. Translation not validated.', 'error');
                }
            });
        }

        // Delete a course
        function deleteCourse(courseId) {
            console.log('deleteCourse: Called for course ID:', courseId);
            if (!isFirebaseReady || !db || !userId) {
                console.error("deleteCourse: Firebase not ready or user not authenticated. isFirebaseReady:", isFirebaseReady, "db:", db, "userId:", userId);
                showMessageBox("Firebase is not ready or user not authenticated. Please wait a moment.", "error");
                return;
            }
            showConfirmBox('Are you sure you want to delete this course and all its terms?', async () => {
                try {
                    // Delete associated terms first
                    console.log('deleteCourse: Querying terms associated with course ID:', courseId);
                    const termsQuery = query(collection(db, 'artifacts', APP_ID, 'public', 'data', 'terms'), where('courseId', '==', courseId));
                    const termsSnapshot = await getDocs(termsQuery);
                    console.log(`deleteCourse: Found ${termsSnapshot.docs.length} terms to delete.`);
                    const deletePromises = termsSnapshot.docs.map(d => {
                        console.log(`deleteCourse: Deleting term document with ID: ${d.id}`);
                        return deleteDoc(d.ref);
                    });
                    await Promise.all(deletePromises);
                    console.log('deleteCourse: All associated terms deleted.');

                    // Then delete course document
                    console.log('deleteCourse: Deleting course document with ID:', courseId);
                    await deleteDoc(doc(db, 'artifacts', APP_ID, 'public', 'data', 'courses', courseId));
                    console.log('deleteCourse: Course deleted successfully.');

                    showMessageBox('Course and associated terms deleted.', 'info', () => {
                        // renderCourses and renderTerms are called by onSnapshot listeners
                        if (currentCourseId === courseId) {
                            currentCourseId = null; // Clear current course if deleted
                            showView(homeView); // Go back to home view
                        }
                    });
                } catch (error) {
                    console.error("deleteCourse: Error deleting course: ", error);
                    showMessageBox('Error deleting course. Please try again.', 'error');
                }
            });
        }

        // Delete a term
        function deleteTerm(termId) {
            console.log('deleteTerm: Called for term ID:', termId);
            if (!isFirebaseReady || !db || !userId) {
                console.error("deleteTerm: Firebase not ready or user not authenticated. isFirebaseReady:", isFirebaseReady, "db:", db, "userId:", userId);
                showMessageBox("Firebase is not ready or user not authenticated. Please wait a moment.", "error");
                return;
            }
            showConfirmBox('Are you sure you want to delete this term?', async () => {
                try {
                    console.log('deleteTerm: Deleting term document with ID:', termId);
                    await deleteDoc(doc(db, 'artifacts', APP_ID, 'public', 'data', 'terms', termId));
                    console.log('deleteTerm: Term deleted successfully.');
                    showMessageBox('Term deleted.', 'info', () => {
                        // renderTerms is called by the onSnapshot listener
                    });
                } catch (error) {
                    console.error("deleteTerm: Error deleting term: ", error);
                    showMessageBox('Error deleting term. Please try again.', 'error');
                }
            });
        }

        // --- NEW: Event Delegation for Term List Actions ---
        termList.addEventListener('click', function(event) {
            console.log('termList click event detected.');
            // Find the closest button with a data-term-id attribute
            const target = event.target.closest('button[data-term-id]');
            
            if (!target) {
                console.log('termList: Clicked element is not a button with data-term-id. Exiting.');
                return; // Exit if a relevant button wasn't clicked
            }

            const termId = target.dataset.termId;
            console.log(`termList: Button clicked for term ID: ${termId}, class list: ${target.classList}`);

            if (target.classList.contains('btn-delete')) {
                deleteTerm(termId);
            } else if (target.classList.contains('btn-edit')) {
                editTerm(termId);
            } else if (target.classList.contains('btn-validate')) {
                const langKey = target.dataset.langKey;
                validateTerm(termId, langKey);
            }
        });

        // Global search functionality
        globalSearchInput.onkeyup = () => {
            console.log('globalSearchInput onkeyup triggered. Current value:', globalSearchInput.value);
            const queryText = globalSearchInput.value.trim().toLowerCase();
            if (queryText.length > 0) {
                const results = appData.terms.filter(term =>
                    // Search across all language texts, pronunciation, and definition
                    LANGUAGES.some(lang =>
                        term[lang.key] && term[lang.key].text && term[lang.key].text.toLowerCase().includes(queryText)
                    ) || (term.definition && term.definition.toLowerCase().includes(queryText)) ||
                    (term.pronunciation && term.pronunciation.toLowerCase().includes(queryText))
                );
                renderSearchResults(results);
            } else {
                searchResultsList.innerHTML = '';
                noSearchResultsMessage.classList.remove('hidden');
            }
        };

        // Clear global search results
        clearSearchBtn.onclick = () => {
            console.log('clearSearchBtn clicked.');
            globalSearchInput.value = '';
            searchResultsList.innerHTML = '';
            noSearchResultsMessage.classList.remove('hidden');
        };

        // Course-specific search functionality (Request 1)
        courseSearchInput.onkeyup = () => {
            console.log('courseSearchInput onkeyup triggered. Current value:', courseSearchInput.value);
            renderTerms(currentCourseId, courseSearchInput.value.trim());
        };

        // Download Terms as CSV (Request 3)
        downloadTermsCsvBtn.onclick = () => {
            console.log('downloadTermsCsvBtn clicked.');
            if (!currentCourseId) {
                showMessageBox('Please select a course first to download its terms.', 'error');
                return;
            }

            const course = appData.courses.find(c => c.id === currentCourseId);
            if (!course) {
                showMessageBox('Course not found.', 'error');
                return;
            }

            const termsToDownload = appData.terms.filter(term => term.courseId === currentCourseId);

            if (termsToDownload.length === 0) {
                showMessageBox('No terms available for this course to download.', 'info');
                return;
            }

            // Define CSV headers
            const headers = ['Hebrew Term', 'Pronunciation', 'Definition'];
            LANGUAGES.filter(lang => lang.key !== 'hebrew').forEach(lang => {
                headers.push(`${lang.name} Translation`);
                headers.push(`${lang.name} Status`);
            });

            const csvRows = [];
            csvRows.push(headers.join(',')); // Add header row

            termsToDownload.forEach(term => {
                const row = [];
                // Main Hebrew term, pronunciation, and definition
                row.push(`"${(term.hebrew && term.hebrew.text) ? term.hebrew.text.replace(/"/g, '""') : ''}"`);
                row.push(`"${term.pronunciation ? term.pronunciation.replace(/"/g, '""') : ''}"`);
                row.push(`"${term.definition ? term.definition.replace(/"/g, '""') : ''}"`);

                // Other translations and their statuses
                LANGUAGES.filter(lang => lang.key !== 'hebrew').forEach(lang => {
                    const translationText = (term[lang.key] && term[lang.key].text) ? term[lang.key].text : '';
                    const status = (term[lang.key] && term[lang.key].status) ? term[lang.key].status : 'Not Provided';
                    row.push(`"${translationText.replace(/"/g, '""')}"`);
                    row.push(`"${status.replace(/"/g, '""')}"`);
                });
                csvRows.push(row.join(','));
            });

            const csvString = csvRows.join('\n');
            const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `${course.name.replace(/\s+/g, '_')}_terms.csv`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            showMessageBox('Terms downloaded successfully as CSV!', 'success');
            console.log('CSV download initiated.');
        };


        // --- Linguini Challenge Game Logic ---

        // Populate language selection dropdown for the challenge game
        function populateChallengeGameLanguageSelect() {
            console.log('populateChallengeGameLanguageSelect called.');
            challengeGameLanguageSelect.innerHTML = '';
            // Add a default "select" option
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'Select your native language';
            defaultOption.disabled = true;
            defaultOption.selected = true;
            challengeGameLanguageSelect.appendChild(defaultOption);

            LANGUAGES.forEach(lang => {
                const option = document.createElement('option');
                option.value = lang.key;
                option.textContent = lang.name;
                challengeGameLanguageSelect.appendChild(option);
            });
        }

        // Start the challenge game
        startChallengeGameButton.onclick = async () => {
            console.log('startChallengeGameButton clicked.');
            // Initialize Tone.js context if not already running (required for sounds)
            if (Tone.context.state !== 'running') {
                console.log('Tone.js context not running. Starting...');
                await Tone.start();
            }

            challengeGameSelectedLanguage = challengeGameLanguageSelect.value;
            if (!challengeGameSelectedLanguage) {
                console.warn('startChallengeGameButton: No language selected.');
                showMessageBox('Please select your native language to start the game.', 'error');
                return;
            }

            // Filter terms to only include those that have a translation in the selected native language
            // and have at least one other language translation to be the source term.
            const playableTerms = appData.terms.filter(term => {
                const hasNativeTranslation = term[challengeGameSelectedLanguage] && term[challengeGameSelectedLanguage].text;
                const hasOtherLanguageTranslation = LANGUAGES.some(lang =>
                    lang.key !== 'hebrew' && lang.key !== challengeGameSelectedLanguage && term[lang.key] && term[lang.key].text
                );
                return hasNativeTranslation && hasOtherLanguageTranslation;
            });
            console.log('startChallengeGameButton: Playable terms count:', playableTerms.length);


            if (playableTerms.length < 2) { // Need at least two terms to generate a question with a distractor
                showMessageBox('Not enough terms with translations in your selected language and another language to play. Please add more terms!', 'error');
                return;
            }

            challengeGameScore = 0;
            challengeGameTimeLeft = 30;
            challengeGameScoreDisplay.textContent = challengeGameScore;
            challengeGameTimerDisplay.textContent = challengeGameTimeLeft;
            challengeGameFeedbackDisplay.textContent = '';

            challengeGameStartScreen.classList.add('hidden');
            challengeGamePlayScreen.classList.remove('hidden');
            challengeGameOverScreen.classList.add('hidden');

            startChallengeTimer();
            generateChallengeQuestion();
        };

        // Challenge Game Timer functionality
        function startChallengeTimer() {
            console.log('startChallengeTimer called.');
            clearInterval(challengeGameTimerInterval); // Clear any existing timer
            challengeGameTimerInterval = setInterval(() => {
                challengeGameTimeLeft--;
                challengeGameTimerDisplay.textContent = challengeGameTimeLeft;
                if (challengeGameTimeLeft <= 0) {
                    console.log('Challenge game timer reached 0.');
                    endChallengeGame();
                }
            }, 1000);
        }

        // Generate a new challenge question
        function generateChallengeQuestion() {
            console.log('generateChallengeQuestion called.');
            // Reset button styles
            challengeOption1Button.classList.remove('correct', 'incorrect');
            challengeOption2Button.classList.remove('correct', 'incorrect');
            challengeGameFeedbackDisplay.textContent = '';
            challengeOption1Button.disabled = false;
            challengeOption2Button.disabled = false;

            const playableTerms = appData.terms.filter(term => {
                const hasNativeTranslation = term[challengeGameSelectedLanguage] && term[challengeGameSelectedLanguage].text;
                const hasOtherLanguageTranslation = LANGUAGES.some(lang =>
                    lang.key !== 'hebrew' && lang.key !== challengeGameSelectedLanguage && term[lang.key] && term[lang.key].text
                );
                return hasNativeTranslation && hasOtherLanguageTranslation;
            });

            if (playableTerms.length < 2) {
                console.warn('generateChallengeQuestion: Not enough playable terms.');
                endChallengeGame('Game ended: Not enough diverse terms to create questions.');
                return;
            }

            // 1. Pick a random term for the question (the one whose translation will be displayed)
            let randomTerm = getRandomElement(playableTerms);
            challengeGameCurrentTerm = randomTerm;
            console.log('generateChallengeQuestion: Selected random term:', challengeGameCurrentTerm);

            // Pick a random source language for the displayed term (not the native language and not Hebrew)
            const sourceLang = getRandomElement(LANGUAGES.filter(lang => lang.key !== challengeGameSelectedLanguage && lang.key !== 'hebrew' && challengeGameCurrentTerm[lang.key] && challengeGameCurrentTerm[lang.key].text));
            if (!sourceLang) {
                console.error('generateChallengeQuestion: No suitable source language found for the selected term.');
                // Fallback to definition if no other language translation is available for the source
                if (challengeGameCurrentTerm.definition) {
                    challengeGameTermDisplay.textContent = challengeGameCurrentTerm.definition;
                    challengeGameTermDisplay.dir = 'ltr'; // Assuming definitions are LTR
                    console.log('generateChallengeQuestion: Displaying definition as fallback source.');
                } else {
                    endChallengeGame('Game ended: Could not find a suitable source term or definition.');
                    return;
                }
            } else {
                challengeGameTermDisplay.textContent = challengeGameCurrentTerm[sourceLang.key].text;
                challengeGameTermDisplay.dir = sourceLang.dir; // Set text direction
                console.log(`generateChallengeQuestion: Displaying term: "${challengeGameTermDisplay.textContent}" in ${sourceLang.name}`);
            }

            const correctTranslation = challengeGameCurrentTerm[challengeGameSelectedLanguage].text;

            // 2. Generate an incorrect option (a translation from a *different* term)
            let incorrectTranslation = '';
            let incorrectTerm = null;
            // Loop until we find a term that is different from challengeGameCurrentTerm
            // and has a translation in the selected native language.
            do {
                incorrectTerm = getRandomElement(playableTerms);
            } while (incorrectTerm.id === challengeGameCurrentTerm.id);

            incorrectTranslation = incorrectTerm[challengeGameSelectedLanguage].text;
            console.log('generateChallengeQuestion: Correct translation:', correctTranslation, 'Incorrect translation:', incorrectTranslation);

            // 3. Prepare options and shuffle them
            const options = [
                { text: correctTranslation, isCorrect: true, key: 'challengeOption1' },
                { text: incorrectTranslation, isCorrect: false, key: 'challengeOption2' }
            ];
            shuffleArray(options);

            challengeOption1Button.textContent = options[0].text;
            challengeOption1Button.dir = LANGUAGES.find(l => l.key === challengeGameSelectedLanguage).dir; // Set option text direction
            challengeOption1Button.onclick = () => checkChallengeAnswer(options[0].isCorrect, 'challengeOption1');

            challengeOption2Button.textContent = options[1].text;
            challengeOption2Button.dir = LANGUAGES.find(l => l.key === challengeGameSelectedLanguage).dir; // Set option text direction
            challengeOption2Button.onclick = () => checkChallengeAnswer(options[1].isCorrect, 'challengeOption2');

            challengeGameCorrectOptionKey = options.find(opt => opt.isCorrect).key; // Store which option is correct
            console.log('generateChallengeQuestion: Options set. Correct option key:', challengeGameCorrectOptionKey);
        }

        // Check the user's answer for challenge game
        function checkChallengeAnswer(isCorrect, clickedOptionKey) {
            console.log(`checkChallengeAnswer: Clicked option: ${clickedOptionKey}, isCorrect: ${isCorrect}`);
            // Disable buttons to prevent multiple clicks
            challengeOption1Button.disabled = true;
            challengeOption2Button.disabled = true;

            const clickedButton = document.getElementById(clickedOptionKey);
            const correctButton = document.getElementById(challengeGameCorrectOptionKey); // Use the stored correct key

            if (isCorrect) {
                challengeGameScore++;
                challengeGameScoreDisplay.textContent = challengeGameScore;
                challengeGameFeedbackDisplay.textContent = 'Correct!';
                challengeGameFeedbackDisplay.classList.remove('text-red-500');
                challengeGameFeedbackDisplay.classList.add('text-emerald-500');
                correctSynth.triggerAttackRelease('C5', '8n'); // Play a note for correct answer
                clickedButton.classList.add('correct');
                console.log('checkChallengeAnswer: Correct answer. Score:', challengeGameScore);
            } else {
                challengeGameFeedbackDisplay.textContent = 'Incorrect!';
                challengeGameFeedbackDisplay.classList.remove('text-emerald-500');
                challengeGameFeedbackDisplay.classList.add('text-red-500');
                incorrectSynth.triggerAttackRelease('C4', '8n'); // Play a different note for incorrect
                clickedButton.classList.add('incorrect');
                correctButton.classList.add('correct'); // Show the correct answer
                console.log('checkChallengeAnswer: Incorrect answer. Score:', challengeGameScore);
            }

            // Wait a moment before generating the next question
            setTimeout(() => {
                if (challengeGameTimeLeft > 0) { // Only generate next if time hasn't run out
                    generateChallengeQuestion();
                } else {
                    console.log('checkChallengeAnswer: Time ran out, ending game.');
                }
            }, 1000); // 1 second delay
        }

        // End the challenge game
        function endChallengeGame(message = '') {
            console.log('endChallengeGame called. Message:', message);
            clearInterval(challengeGameTimerInterval);
            gameOverSynth.triggerAttackRelease('C2', '2n'); // Game over sound

            challengeGamePlayScreen.classList.add('hidden');
            challengeGameOverScreen.classList.remove('hidden');
            challengeFinalScoreDisplay.textContent = challengeGameScore;

            if (message) {
                showMessageBox(message, 'info', () => {
                    showView(challengeGameView); // Go back to game start screen
                    challengeGameStartScreen.classList.remove('hidden');
                    challengeGamePlayScreen.classList.add('hidden');
                    challengeGameOverScreen.classList.add('hidden');
                });
            }
            console.log('endChallengeGame: Game over. Final score:', challengeGameScore);
        }

        // Play again button for challenge game
        playAgainChallengeButton.onclick = () => {
            console.log('playAgainChallengeButton clicked.');
            challengeGameStartScreen.classList.remove('hidden');
            challengeGamePlayScreen.classList.add('hidden');
            challengeGameOverScreen.classList.add('hidden');
            challengeGameScore = 0;
            challengeGameTimeLeft = 30;
            challengeGameScoreDisplay.textContent = challengeGameScore;
            challengeGameTimerDisplay.textContent = challengeGameTimeLeft;
            challengeGameFeedbackDisplay.textContent = '';
        };


        // --- Learn Hebrew Game Logic ---

        // Populate language selection dropdown for learn Hebrew game
        function populateLearnHebrewLanguageSelect() {
            console.log('populateLearnHebrewLanguageSelect called.');
            learnHebrewLanguageSelect.innerHTML = '';
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'Select your native language';
            defaultOption.disabled = true;
            defaultOption.selected = true;
            learnHebrewLanguageSelect.appendChild(defaultOption);

            LANGUAGES.filter(lang => lang.key !== 'hebrew').forEach(lang => { // Exclude Hebrew as native language for learning Hebrew
                const option = document.createElement('option');
                option.value = lang.key;
                option.textContent = lang.name;
                learnHebrewLanguageSelect.appendChild(option);
            });
        }

        // Start learning session
        startLearningButton.onclick = async () => {
            console.log('startLearningButton clicked.');
            if (Tone.context.state !== 'running') {
                console.log('Tone.js context not running. Starting...');
                await Tone.start();
            }

            learnHebrewSelectedLanguage = learnHebrewLanguageSelect.value;
            if (!learnHebrewSelectedLanguage) {
                console.warn('startLearningButton: No language selected.');
                showMessageBox('Please select your native language to start learning.', 'error');
                return;
            }

            // Filter terms that have both a Hebrew term and a translation in the selected native language
            // Use the dedicated `learnHebrewVocabulary` for this game
            learningTerms = learnHebrewVocabulary.filter(term =>
                term.hebrew && term[learnHebrewSelectedLanguage]
            );
            console.log('startLearningButton: Learning terms count:', learningTerms.length);


            if (learningTerms.length < 2) { // Need at least two terms to generate a question with a distractor
                showMessageBox('Not enough Hebrew terms with translations in your selected language available for learning. Please add more terms to the vocabulary!', 'error');
                return;
            }

            shuffleArray(learningTerms); // Randomize the order of terms
            currentLearningIndex = 0;
            masteredWordsCount = 0;
            masteredWordsCountDisplay.textContent = masteredWordsCount;

            learnHebrewStartScreen.classList.add('hidden');
            learnHebrewPlayScreen.classList.remove('hidden');
            learnHebrewEndScreen.classList.add('hidden');

            displayNextLearningTerm();
        };

        // Display the next Hebrew term flashcard
        function displayNextLearningTerm() {
            console.log(`displayNextLearningTerm called. Current index: ${currentLearningIndex}, total terms: ${learningTerms.length}`);
            if (currentLearningIndex >= learningTerms.length) {
                endLearningSession();
                return;
            }

            const term = learningTerms[currentLearningIndex];
            hebrewTermDisplay.textContent = term.hebrew;
            pronunciationDisplay.textContent = `(${term.pronunciation})`;
            learnHebrewFeedbackDisplay.textContent = ''; // Clear feedback
            learnHebrewOption1Button.disabled = false; // Enable buttons
            learnHebrewOption2Button.disabled = false;
            learnHebrewOption1Button.classList.remove('correct', 'incorrect'); // Reset button styles
            learnHebrewOption2Button.classList.remove('correct', 'incorrect');
            learnHebrewNextWordButton.classList.add('hidden'); // Hide next button

            const correctTranslation = term[learnHebrewSelectedLanguage];
            console.log(`displayNextLearningTerm: Displaying Hebrew: "${term.hebrew}", Correct translation: "${correctTranslation}"`);

            // Generate an incorrect option (a translation from a *different* term)
            let incorrectTranslation = '';
            let incorrectTerm = null;
            do {
                incorrectTerm = getRandomElement(learningTerms);
            } while (incorrectTerm === term || !incorrectTerm[learnHebrewSelectedLanguage]); // Ensure different term and has translation

            incorrectTranslation = incorrectTerm[learnHebrewSelectedLanguage];
            console.log('displayNextLearningTerm: Incorrect translation:', incorrectTranslation);

            // Prepare options and shuffle them
            const options = [
                { text: correctTranslation, isCorrect: true, key: 'learnHebrewOption1' },
                { text: incorrectTranslation, isCorrect: false, key: 'learnHebrewOption2' }
            ];
            shuffleArray(options);

            learnHebrewOption1Button.textContent = options[0].text;
            learnHebrewOption1Button.dir = LANGUAGES.find(l => l.key === learnHebrewSelectedLanguage).dir;
            learnHebrewOption1Button.onclick = () => checkLearnHebrewAnswer(options[0].isCorrect, 'learnHebrewOption1');

            learnHebrewOption2Button.textContent = options[1].text;
            learnHebrewOption2Button.dir = LANGUAGES.find(l => l.key === learnHebrewSelectedLanguage).dir;
            learnHebrewOption2Button.onclick = () => checkLearnHebrewAnswer(options[1].isCorrect, 'learnHebrewOption2');

            // Store which option is correct for feedback
            learnHebrewOption1Button.dataset.isCorrect = options[0].isCorrect;
            learnHebrewOption2Button.dataset.isCorrect = options[1].isCorrect;

            updateLearningProgress();
        }

        // Update learning progress display
        function updateLearningProgress() {
            learningProgressDisplay.textContent = `${currentLearningIndex + 1}/${learningTerms.length}`;
            if (currentLearningIndex >= learningTerms.length) {
                 learningProgressDisplay.textContent = `${learningTerms.length}/${learningTerms.length}`;
            }
            console.log('updateLearningProgress: Progress:', learningProgressDisplay.textContent);
        }

        // Check the user's answer for Learn Hebrew game
        function checkLearnHebrewAnswer(isCorrect, clickedOptionId) {
            console.log(`checkLearnHebrewAnswer: Clicked option: ${clickedOptionId}, isCorrect: ${isCorrect}`);
            // Disable buttons to prevent multiple clicks
            learnHebrewOption1Button.disabled = true;
            learnHebrewOption2Button.disabled = true;

            const clickedButton = document.getElementById(clickedOptionId);

            if (isCorrect) {
                masteredWordsCount++;
                masteredWordsCountDisplay.textContent = masteredWordsCount;
                learnHebrewFeedbackDisplay.textContent = 'Correct!';
                learnHebrewFeedbackDisplay.classList.remove('text-red-500');
                learnHebrewFeedbackDisplay.classList.add('text-emerald-500');
                correctSynth.triggerAttackRelease('C5', '8n');
                clickedButton.classList.add('correct');
                console.log('checkLearnHebrewAnswer: Correct answer. Mastered count:', masteredWordsCount);
            } else {
                learnHebrewFeedbackDisplay.textContent = 'Incorrect!';
                learnHebrewFeedbackDisplay.classList.remove('text-emerald-500');
                learnHebrewFeedbackDisplay.classList.add('text-red-500');
                incorrectSynth.triggerAttackRelease('C4', '8n');
                clickedButton.classList.add('incorrect');

                // Show the correct answer
                if (learnHebrewOption1Button.dataset.isCorrect === 'true') {
                    learnHebrewOption1Button.classList.add('correct');
                } else {
                    learnHebrewOption2Button.classList.add('correct');
                }
                console.log('checkLearnHebrewAnswer: Incorrect answer. Mastered count:', masteredWordsCount);
            }
            learnHebrewNextWordButton.classList.remove('hidden'); // Show next button
        }

        // Move to the next word in Learn Hebrew game
        learnHebrewNextWordButton.onclick = () => {
            console.log('learnHebrewNextWordButton clicked.');
            currentLearningIndex++;
            displayNextLearningTerm();
        };

        // End learning session
        function endLearningSession() {
            console.log('endLearningSession called.');
            learnHebrewPlayScreen.classList.add('hidden');
            learnHebrewEndScreen.classList.remove('hidden');
            finalMasteredCountDisplay.textContent = masteredWordsCount;
            console.log('Learning session ended. Final mastered count:', masteredWordsCount);
        }

        // Start new learning session
        startNewLearningSessionButton.onclick = () => {
            console.log('startNewLearningSessionButton clicked.');
            learnHebrewStartScreen.classList.remove('hidden');
            learnHebrewPlayScreen.classList.add('hidden');
            learnHebrewEndScreen.classList.add('hidden');
            masteredWordsCount = 0;
            currentLearningIndex = 0;
            masteredWordsCountDisplay.textContent = masteredWordsCount;
            learnHebrewLanguageSelect.value = ''; // Reset language selection
        };


        // --- Navigation Logic ---

        // Function to view course details
        function viewCourseDetails(id) {
            console.log('viewCourseDetails called for ID:', id);
            currentCourseId = id;
            const course = appData.courses.find(c => c.id === id);
            if (course) {
                courseDetailsTitle.textContent = course.name;
                courseSearchInput.value = ''; // Clear course search when navigating
                renderTerms(id);
                showView(courseDetailsView);
            } else {
                console.warn('viewCourseDetails: Course not found for ID:', id);
                showMessageBox('Course not found.', 'error', () => {
                    showView(homeView);
                    renderCourses();
                });
                currentCourseId = null; // Reset current course ID if not found
            }
        }

        // Event listeners for navigation buttons
        homeButton.onclick = () => {
            console.log('homeButton clicked.');
            showView(homeView);
            // renderCourses is called by the onSnapshot listener
            // Reset search and game states when returning home
            globalSearchInput.value = '';
            searchResultsList.innerHTML = '';
            noSearchResultsMessage.classList.remove('hidden');
            currentCourseId = null;
            currentTermId = null;
            clearInterval(challengeGameTimerInterval); // Stop challenge game timer
        };
        showAddCourseFormBtn.onclick = () => {
            console.log('showAddCourseFormBtn clicked.');
            showView(addCourseView);
        };
        cancelAddCourseBtn.onclick = () => {
            console.log('cancelAddCourseBtn clicked.');
            addCourseForm.reset();
            showView(homeView);
        };
        showAddTermFormBtn.onclick = () => {
            console.log('showAddTermFormBtn clicked.');
            // Prepare form for adding a new term
            addTermForm.reset();
            addTermFormTitle.textContent = 'Add New Term';
            addTermSubmitBtn.textContent = 'Add Term';
            currentTermId = null; // Ensure we're in "add new" mode
            // Clear the new pronunciation input when adding a new term
            termPronunciationInput.value = '';
            showView(addTermView);
        };
        cancelAddTermBtn.onclick = () => {
            console.log('cancelAddTermBtn clicked.');
            addTermForm.reset();
            currentTermId = null; // Clear editing state
            if (currentCourseId) {
                viewCourseDetails(currentCourseId); // Go back to course details if a course was selected
            } else {
                showView(homeView); // Otherwise go to home
            }
        };

        // "Linguini Challenge" button click handler
        challengeGameButton.onclick = () => {
            console.log('challengeGameButton clicked.');
            showView(challengeGameView);
            challengeGameStartScreen.classList.remove('hidden');
            challengeGamePlayScreen.classList.add('hidden');
            challengeGameOverScreen.classList.add('hidden');
            populateChallengeGameLanguageSelect(); // Ensure dropdown is fresh
        };

        // "Search" button click handler
        searchButton.onclick = () => {
            console.log('searchButton clicked.');
            showView(searchView);
            globalSearchInput.value = ''; // Clear search input when entering search view
            searchResultsList.innerHTML = '';
            noSearchResultsMessage.classList.remove('hidden');
        };

        // "Learn Hebrew" button click handler
        learnHebrewButton.onclick = () => {
            console.log('learnHebrewButton clicked.');
            showView(learnHebrewView);
            learnHebrewStartScreen.classList.remove('hidden');
            learnHebrewPlayScreen.classList.add('hidden');
            learnHebrewEndScreen.classList.add('hidden');
            populateLearnHebrewLanguageSelect(); // Ensure dropdown is fresh
        };
    </script>
</body>
</html>
